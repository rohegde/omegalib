<!--**************************************************************************************************
 * THE OMEGA LIB PROJECT
 *-------------------------------------------------------------------------------------------------
 * Copyright 2010-2011		Electronic Visualization Laboratory, University of Illinois at Chicago
 * Authors:										
 *  Donghi Daniele		d.donghi@gmail.com
 *-------------------------------------------------------------------------------------------------
 * Copyright (c) 2010-2011, Electronic Visualization Laboratory, University of Illinois at Chicago
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without modification, are permitted 
 * provided that the following conditions are met:
 * 
 * Redistributions of source code must retain the above copyright notice, this list of conditions 
 * and the following disclaimer. Redistributions in binary form must reproduce the above copyright 
 * notice, this list of conditions and the following disclaimer in the documentation and/or other 
 * materials provided with the distribution. 
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND 
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF 
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN 
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *************************************************************************************************-->
<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset=utf-8 />
 <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
 <meta name="apple-mobile-web-app-capable" content="yes"/>
 <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
 <title>Porthole</title>

 <link rel="stylesheet" type="text/css" href="./porthole.css" />
 <script type="application/javascript" src="./porthole_functions_binder.js" ></script>

 <!--CSS Style-->
 <style type="text/css">
    html, body
    {
        width: 100%;
        height: 100%;
        margin: 0;
        overflow: auto;
        font: 78%/120% arial, sans-serif;
        line-height: 120%;
    }
    .ui-autocomplete { overflow-y: auto; width:300px;}
    * html .ui-autocomplete { /* IE max- */height: expression( this.scrollHeight > 320 ? "320px" : "auto" ); }
    .ui-autocomplete { max-height: 320px; }
    .ui-autocomplete li { font-size:10pt; }
 </style>

</head>

<body>

 <div id="porthole_content"  style=" width : 100%; height : 100%; ">Initializing porthole... </div>

 <script src="http://raw.github.com/devongovett/png.js/master/zlib.js"></script>
 <script src="http://raw.github.com/devongovett/png.js/master/png.js"></script>
 <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js" type="text/javascript"></script>

 <!--Google Maps libs START-->
 <script src="http://maps.google.com/maps/api/js?sensor=true&libraries=places" type="text/javascript"></script>
 <script type="text/javascript" src="http://geo-autocomplete.googlecode.com/svn/trunk/lib/jquery-ui/js/jquery-ui-1.8.5.custom.min.js"></script>
 <script type="text/javascript" src="./ui.geo_autocomplete.js"></script>
 <link rel="stylesheet" type="text/css" href="http://code.jquery.com/ui/1.8.23/themes/ui-lightness/jquery-ui.css" />
 <!--Google Maps libs END-->

 <script src="http://raw.github.com/EightMedia/hammer.js/master/hammer.js" type="application/javascript"></script>
 <script src="https://raw.github.com/EightMedia/hammer.js/master/jquery.specialevent.hammer.js" type="application/javascript"></script>

 <script type="application/javascript">

    var firstTime = 1;

    // Mobile or desktop
    var isMobile;
    if (screen.width <= 699) {
        isMobile = true;
    }
    else {
        isMobile = false;
    }

    // Disable global scrolling
    document.body.addEventListener('touchmove', function (event) {
        event.preventDefault();
    }, false); 

    ///////////////// DEFINE METADATA AT RUNTIME ////////////////////////
    function setOrCreateMetaTag(metaName, name, value) {
        var t = 'meta['+metaName+'='+name+']';
        var mt = $(t);
        if (mt.length === 0) {
            t = '<meta '+metaName+'="'+name+'" />';
            mt = $(t).appendTo('head');
        }
        mt.attr('content', value);
    }

    ///////////////// ADD AN EVENT HANDLER ////////////////////////
    var addEvent = function (elem, type, eventHandle) {
        if (elem == null || elem == undefined) return;
        if (elem.addEventListener) {
            elem.addEventListener(type, eventHandle, false);
        } else if (elem.attachEvent) {
            elem.attachEvent("on" + type, eventHandle);
        } else {
            elem["on" + type] = eventHandle;
        }
    };

    ////////////////// WEBSCOKET AND CANVAS ////////////////////////////

    function get_appropriate_ws_url() {
        /*
        * We open the websocket encrypted if this page came on an
        * https:// url itself, otherwise unencrypted
        */
        var pcol;
        var u = document.URL;

        if (u.substring(0, 5) == "https") {
            pcol = "wss://";
            u = u.substr(8);
        } else {
            pcol = "ws://";
            if (u.substring(0, 4) == "http")
                u = u.substr(7);
        }

        u = u.split('/');

        return pcol + u[0];
    }

    if ("WebSocket" in window) {
        socket = new WebSocket(get_appropriate_ws_url(), "porthole_websocket");
    } else if ("MozWebSocket" in window) {
        socket = new MozWebSocket(get_appropriate_ws_url(), "porthole_websocket");
    } else {
        document.getElementById("porthole_content").innerHTML = 
            "This Browser does not support WebSockets.<br />If using Opera, make sure to enable WebSockets.";
    }

    ///////////////////// SEND SPEC TO SERVER //////////////////////////

    function sendSpec() {

        var w=window,d=document,e=d.documentElement,g=d.getElementsByTagName('body')[0],
            viewportwidth=w.innerWidth||e.clientWidth||g.clientWidth,
            viewportheight=w.innerHeight||e.clientHeight||g.clientHeight;

        var orientation;

        if (window.orientation & 2) {
                // landscape mode
                orientation = "landscape";
            } else {
                // portrait mode
                orientation = "portrait";
            }

        var SpecMessage = {
            "event_type": "device_spec",
            "width": viewportwidth,
            "height": viewportheight,
            "orientation": orientation,
            "first_time": firstTime
        }

        socket.send(JSON.stringify(SpecMessage));
    }

    var img = new Image();
    var ctx;
    var camera;

    try {
        socket.onopen = function () {
            // Send device specifications
            sendSpec();
        }

        socket.onmessage = function got_packet(msg) {
            //            document.getElementById("porthole_content").textContent = msg.data + "\n";

            var message = JSON.parse(msg.data);

            if (message.event_type == "stream") {
                image = "data:image/png;base64," + message.base64image;
                img.src = image;
                ctx.drawImage(img, 0, 0, camera.width, camera.height);

            }
            else {
                document.getElementById("porthole_content").innerHTML = message.innerHTML;

                // TEST googlemap initialization
                initializeGoogleMaps();
                initializeCameraStreams();

                // Add events listeners
                if (!isMobile) {
                    addEvent(window, "resize", sendSpec);
                }
                addEvent(window, "orientationchange", sendSpec);

                firstTime = 0;

            }

        }

        socket.onclose = function () {
            document.getElementById("porthole_content").innerHTML = " websocket connection CLOSED ";
        }
    } catch (exception) {
        alert('<p>Error' + exception);
    }

    //////////////////////////////////////////////////////////

    // Hammer object
    var hammer;

    // Drag vars
    var dragging = false;
    var dragPosX, dragPosY;
    var dragOldX, dragOldY;

    // Pinch vars
    var pinching = false;
    var pinchScale, pinchRotation;
    var pinchOldScale, pinchOldRotation;

    ///////////////////////////////////////////////////////////

    // Drag functions
    function watchDrag() {
        if (!dragging || pinching) return;
        var JSONEvent = {
            "event_type": "drag",
            "camera_id": parseInt(camera.getAttribute("data-camera_id")),
            "deltaX": parseFloat(((dragPosX - dragOldX) / camera.width) * 90), // yaw delta
            "deltaY": parseFloat(((dragPosY - dragOldY) / camera.height) * 90) // pitch delta
        };
        socket.send(JSON.stringify(JSONEvent));
        dragOldX = dragPosX;
        dragOldY = dragPosY;
    }

    // Pinch functions
    function watchPinch() {
        if (!pinching) return;
        if (pinchScale - pinchOldScale == 0 && pinchRotation - pinchOldRotation == 0) return;
        var JSONEvent = {
            "event_type": "pinch",
            "camera_id": parseInt(camera.getAttribute("data-camera_id")),
            "scale": pinchScale,
            "rotation": parseFloat(pinchRotation - pinchOldRotation)
        };
        socket.send(JSON.stringify(JSONEvent));
        pinchOldScale = pinchScale;
        pinchOldRotation = pinchRotation;
    }

    // Dragging listening interval
    setInterval(watchDrag, 10);
    setInterval(watchPinch, 200);

    ///////////////////////////////////////////////////////////

    function initializeCameraStreams() {
        camera = document.getElementById('camera-canvas');

        if (camera == null) return;

        camera.width = camera.parentNode.clientWidth;
        camera.height = camera.parentNode.clientHeight;

        ctx = camera.getContext("2d");

        hammer = new Hammer(camera, {
            prevent_default: true,

            drag: true,
            drag_vertical: true,
            drag_horizontal: true,
            drag_min_distance: 5,

            transform: true,
            scale_treshold: 0.00001,
            rotation_treshold: 1,

            tap: false,
            tap_double: false,
            hold: false
        });

        ////////////////// MULTITOUCH ////////////////////////////

        hammer.ondragstart = function (ev) {
            dragging = true;
            dragOldX = ev.position.x;
            dragOldY = ev.position.y;
        };
        hammer.ondragend = function (ev) {
            dragging = false;
        };
        hammer.ondrag = function (ev) {
            dragPosX = ev.position.x;
            dragPosY = parseInt(ev.position.y); // y is floating by default, so cast it
        };

        hammer.onswipe = function (ev) { };

        hammer.ontap = function (ev) { };
        hammer.ondoubletap = function (ev) { };

        hammer.ontransformstart = function (ev) {
            dragging = false;
            pinching = true;
            pinchOldRotation = 0;
            pinchRotation = ev.rotation;
            pinchOldScale = 1;
        };
        hammer.ontransformend = function (ev) {
            pinching = false;
        };
        hammer.ontransform = function (ev) {
            dragging = false; // Avoid overlapping of drag and pinch events

            pinchScale = parseFloat(ev.scale);
            pinchRotation = ev.rotation;

            //document.getElementById("porthole_drawing").textContent = "Pinch: scale = " + pinchScale + " rotation = "+ pinchRotation + " deltaRotation = "+ deltaRotation;
        };

        hammer.onrelease = function (ev) { };
        hammer.onhold = function (ev) { };

    }

    ///////////////////////////////////////////////////////////
    //////////////////// Google Maps  /////////////////////////
    var map;
    var service;

    var events = {
        'bounds_changed': 'fired when the viewport bounds have changed.',
        'center_changed': 'fired when the map center property changes.',
        'click': 'fired when the user clicks on the map (but not when they click on a marker or infowindow).',
        'dblclick': 'fired when the user double-clicks on the map. Note that the click event will also fire, right before this one.',
        'drag': 'repeatedly fired while the user drags the map.',
        'dragend': 'fired when the user stops dragging the map.',
        'dragstart': 'fired when the user starts dragging the map.',
        'heading_changed': 'fired when the map heading property changes.',
        'idle': 'fired when the map becomes idle after panning or zooming.',
        'maptypeid_changed': 'fired when the mapTypeId property changes.',
        'mousemove': 'fired whenever the user\'s mouse moves over the map container.',
        'mouseout': 'fired when the user\'s mouse exits the map container.',
        'mouseover': 'fired when the user\'s mouse enters the map container.',
        'projection_changed': 'fired when the projection has changed.',
        'resize': 'Developers should trigger this event on the map when the div changes size: google.maps.event.trigger(map, \'resize\') .',
        'rightclick': 'fired when the DOM contextmenu event is fired on the map container.',
        'tilesloaded': 'fired when the visible tiles have finished loading.',
        'tilt_changed': 'fired when the map tilt property changes.',
        'zoom_changed': 'fired when the map zoom property changes.'
    };

    function initializeGoogleMaps() {

        var mapDiv = document.getElementById('map-canvas');
        if (mapDiv == null) return;

        // Create a StreetViewService to be able to check
        // if a given LatLng has a corresponding panorama.
        service = new google.maps.StreetViewService();

        map = new google.maps.Map(mapDiv, {
            center: new google.maps.LatLng(37.4419, -122.1419),
            zoom: 13,
            mapTypeId: google.maps.MapTypeId.ROADMAP,
            streetViewControl: false // Orange man visible or not
        });

        // getPanoramaByLocation will return the nearest pano when the
        // given radius is 50 meters or less.
        google.maps.event.addListener(map, 'click', function (event) {
            service.getPanoramaByLocation(event.latLng, 100, processSVData);
        });

        var marker = new google.maps.Marker({
            map: map
        });

        // Set autocomplete on text input
        var input = document.getElementById('searchTextField');

        // Add autocomplete
        $('#searchTextField').geo_autocomplete({
            select: function (_event, _ui) {
                if (_ui.item.viewport) {
                    map.fitBounds(_ui.item.viewport);
                    marker.setPosition(_ui.item.location);
                }
            }
        });

    }

    function processSVData(data, status) {
        if (status == google.maps.StreetViewStatus.OK) {

            var JSONEvent = {
                "event_type": "gmap_selection",
                "latlng": data.location.latLng,
                "panoId": data.location.pano // String containing a PanoId
            };
            socket.send(JSON.stringify(JSONEvent));

        } else {
            alert('Street View data not found for this location.');
        }
    }

</script>

</body>
</html>
