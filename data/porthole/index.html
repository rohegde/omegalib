<!--**************************************************************************************************
 * THE OMEGA LIB PROJECT
 *-------------------------------------------------------------------------------------------------
 * Copyright 2010-2011		Electronic Visualization Laboratory, University of Illinois at Chicago
 * Authors:										
 *  Donghi Daniele		d.donghi@gmail.com
 *-------------------------------------------------------------------------------------------------
 * Copyright (c) 2010-2011, Electronic Visualization Laboratory, University of Illinois at Chicago
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without modification, are permitted 
 * provided that the following conditions are met:
 * 
 * Redistributions of source code must retain the above copyright notice, this list of conditions 
 * and the following disclaimer. Redistributions in binary form must reproduce the above copyright 
 * notice, this list of conditions and the following disclaimer in the documentation and/or other 
 * materials provided with the distribution. 
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND 
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF 
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN 
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *************************************************************************************************-->
<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset=utf-8 />
 <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js" type="text/javascript"></script>
 <script src="./hammer.js" type="application/javascript"></script>
 <script src="./jquery.specialevent.hammer.js" type="application/javascript"></script>
 <script src="./browser_detect.js" type="application/javascript"></script>
 <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
 <meta name="apple-mobile-web-app-capable" content="yes"/>
 <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
 <title>Porthole</title>

 <!--CSS Style-->
 <style type="text/css">
    body{
    margin: 0;
    padding: 0
    }
 </style>

</head>

<body>
<!--<h3>Detected Browser: <div id=brow>...</div></h3>-->
<table>
	<tr>
<!--		<td align=center><input type=button id=offset value="Reset counter" onclick="reset();" ></td>-->
		<td id=wsdi_statustd align=center><div id=wsdi_status>Not initialized</div></td>
        <td align=center><div id=porthole_drawing> </div></td>
	</tr>
</table>

<!--<img src="" id="frame" style="width:840px;height:480px"/>-->

<script>

    BrowserDetect.init();

    ///////////////// DEFINE METADATA AT RUNTIME ////////////////////////
    function setOrCreateMetaTag(metaName, name, value) {
        var t = 'meta['+metaName+'='+name+']';
        var mt = $(t);
        if (mt.length === 0) {
            t = '<meta '+metaName+'="'+name+'" />';
            mt = $(t).appendTo('head');
        }
        mt.attr('content', value);
    }
    
    // JUST FOR TEST
//    document.getElementById("brow").textContent = " " + BrowserDetect.browser + " "
//	+ BrowserDetect.version + " " + BrowserDetect.OS + " ";

    ////////////////// WEBSCOKET AND CANVAS ////////////////////////////

    var canvas = document.createElement('canvas');
    ctx = canvas.getContext("2d");
    canvas.width = 840;
    canvas.height = 480;

    // TEST case: append cavas to body tag
    var _body = document.getElementsByTagName('body')[0];
    _body.appendChild(canvas);
    var img = new Image();

    function get_appropriate_ws_url() {
        /*
        * We open the websocket encrypted if this page came on an
        * https:// url itself, otherwise unencrypted
        */
        var pcol;
        var u = document.URL;

        if (u.substring(0, 5) == "https") {
            pcol = "wss://";
            u = u.substr(8);
        } else {
            pcol = "ws://";
            if (u.substring(0, 4) == "http")
                u = u.substr(7);
        }

        u = u.split('/');

        return pcol + u[0];
    }

    var socket;

    if (BrowserDetect.browser == "Firefox" && BrowserDetect.version < 12) {
        socket = new MozWebSocket(get_appropriate_ws_url(),
				   "porthole_websocket");
    } else {
        socket = new WebSocket(get_appropriate_ws_url(),
				   "porthole_websocket");
    }


    ///////////////////// SEND SPEC TO SERVER //////////////////////////
    function sendSpec() {

        var w=window,d=document,e=d.documentElement,g=d.getElementsByTagName('body')[0],
            viewportwidth=w.innerWidth||e.clientWidth||g.clientWidth,
            viewportheight=w.innerHeight||e.clientHeight||g.clientHeight;

        var orientation;

        if (window.orientation & 2) {
                // landscape mode
                orientation = "landscape";
            } else {
                // portrait mode
                orientation = "portrait";
            }

        var SpecMessage = {
            "event_type": "device_spec",
            "width": viewportwidth,
            "height": viewportheight,
            "orientation": orientation
        }

        socket.send(JSON.stringify(SpecMessage));
    }

    window.addEventListener('orientationchange', function() {
        // TODO Reset elements
        sendSpec();
        }, false);

    try {
        socket.onopen = function () {
            document.getElementById("wsdi_statustd").style.backgroundColor = "#40ff40";
            document.getElementById("wsdi_status").textContent = " websocket connection opened ";
            // Send device specifications
            sendSpec();
        }

        socket.onmessage = function got_packet(msg) {
            //            document.getElementById("porthole_drawing").textContent = msg.data + "\n";

            image = "data:image/png;base64," + msg.data;
            img.src = image;

            ctx.drawImage(img, 0, 0);

        }

        socket.onclose = function () {
            document.getElementById("wsdi_statustd").style.backgroundColor = "#ff4040";
            document.getElementById("wsdi_status").textContent = " websocket connection CLOSED ";
        }
    } catch (exception) {
        alert('<p>Error' + exception);
    }

    function reset() {
        socket.send("reset\n");
    }

    //////////////////////////////////////////////////////////

    ////////////////// MULTITOUCH ////////////////////////////

    // Initialize hammer
    var hammer = new Hammer(canvas, {
            prevent_default: true,

            drag: true,
            drag_vertical: true,
            drag_horizontal: true,
            drag_min_distance: 0,

            transform: true,
            scale_treshold: 0.001,
            rotation_treshold: 0.01,

            tap: false,
            tap_double: false,
            hold: false
        });

    // Drag vars
    var dragging = false;
    var dragPosX, dragPosY, dragDistX, dragDistY;
    var deltaX, deltaY;
    
    // Pinch vars
    var pinching = false;
    var pinchScale, pinchRotation;
    var deltaRotation;

    // Drag functions
    function watchDrag() {
        if (!dragging || pinching || deltaX == null || deltaY == null || 
                deltaX == "null" || deltaY == "null") {
            return;
        }
        var JSONOEvent = {
            "event_type": "drag",
            "deltaX": deltaX,
            "deltaY": deltaY
        };
        socket.send(JSON.stringify(JSONOEvent));
    }

    hammer.ondragstart = function (ev) {
        dragging = true;
    };
    hammer.ondragend = function (ev) {
        dragging = false;
    };
    hammer.ondrag = function (ev) {

        deltaX = ev.distanceX - dragDistX;
        deltaY = ev.distanceY - dragDistY;

        dragPosX = ev.position.x;
        dragPosY = parseInt(ev.position.y); // y is floating by default, so cast it
        dragDistX = ev.distanceX;
        dragDistY = ev.distanceY;

    };

    hammer.onswipe = function (ev) { };

    hammer.ontap = function (ev) {};
    hammer.ondoubletap = function (ev) { };

    // Pinch functions
    function watchPinch() {
        if (!pinching || pinchScale == null || pinchRotation == null ||
                pinchScale == "null" || pinchRotation == "null") {
            return;
        }
        var JSONOEvent = {
            "event_type": "pinch",
            "scale": pinchScale,
            "rotation": deltaRotation,
        };
        socket.send(JSON.stringify(JSONOEvent));
    }
    hammer.ontransformstart = function (ev) { 
        dragging = false;
        pinching = true;
    };
    hammer.ontransformend = function (ev) {
        pinching = false;
    };
    hammer.ontransform = function (ev) { 
        dragging = false; // Avoid overlapping of drag and pinch events

        deltaRotation = parseFloat(pinchRotation - ev.rotation);

        pinchScale = parseFloat(ev.scale);
        pinchRotation = ev.rotation;

        //document.getElementById("porthole_drawing").textContent = "Pinch: scale = " + pinchScale + " rotation = "+ pinchRotation + " deltaRotation = "+ deltaRotation;
    };

    hammer.onrelease = function (ev) { };
    hammer.onhold = function (ev) { };

    ///////////////////////////////////////////////////////////

    // Dragging listening interval
    setInterval(watchDrag, 20);
    setInterval(watchPinch, 20);

</script>

</body>
</html>
