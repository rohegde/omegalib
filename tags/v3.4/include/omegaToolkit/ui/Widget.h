/**************************************************************************************************
 * THE OMEGA LIB PROJECT
 *-------------------------------------------------------------------------------------------------
 * Copyright 2010-2013		Electronic Visualization Laboratory, University of Illinois at Chicago
 * Authors:										
 *  Alessandro Febretti		febret@gmail.com
 *-------------------------------------------------------------------------------------------------
 * Copyright (c) 2010-2013, Electronic Visualization Laboratory, University of Illinois at Chicago
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without modification, are permitted 
 * provided that the following conditions are met:
 * 
 * Redistributions of source code must retain the above copyright notice, this list of conditions 
 * and the following disclaimer. Redistributions in binary form must reproduce the above copyright 
 * notice, this list of conditions and the following disclaimer in the documentation and/or other 
 * materials provided with the distribution. 
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND 
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF 
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN 
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *************************************************************************************************/
#ifndef __WIDGET_H__
#define __WIDGET_H__

#include "omegaToolkit/omegaToolkitConfig.h"
#include "omega/DrawInterface.h"
#include "omega/Renderable.h"

namespace omegaToolkit { 
	class UiScriptCommand;
	namespace ui {
    class Container;
    ///////////////////////////////////////////////////////////////////////////////////////////////
    class OTK_API Widget: public RenderableFactory, IEventListener
    {
    friend class UiManager;
    friend class UiRenderPass;
    friend class Container;
    friend class WidgetRenderable;
    public:
		enum Layer { Back, Middle, Front, NumLayers };
		enum BlendMode { BlendInherit, BlendNormal, BlendAdditive, BlendDisabled };
		static const int MaxWidgets = 16384;
    public:
        Widget(Engine* server);
        virtual ~Widget();

        virtual Renderable* createRenderable();

        virtual void handleEvent(const Event& evt);
        virtual void update(const omega::UpdateContext& context);

        //! Sets the event listener used to handle events generated by this widget.
        void setUIEventHandler(IEventListener* value);
        //! @see setWidgetEventHandler
        IEventListener* getUIEventHandler();

		void setUIEventCommand(const String& command);

        //! Gets the color used when widget debug mode is enabled.
        Color getDebugColor() { return myDebugModeColor; }

        //! Sets the color used when widget debug mode is enabled.
        void setDebugColor( omega::Color value ) { myDebugModeColor = value; }

        //! Returns true if debug mode is enabled for this widget.
        bool isDebugModeEnabled() { return myDebugModeEnabled; }

        //! Enabled or disabled debug mode for this widget.
        //! When debug mode is enabled, the widget bounding box will be displayed.
        void setDebugModeEnabled(bool value) { myDebugModeEnabled = value; }

        //! Returns the widget name.
        const String& getName();
        //! Sets the widget name.
        void setName(const String& name);

        //! Position and rotation
        //@{
        //! Gets the widget position.
        const Vector2f& getPosition() { return myPosition; }
        //! Sets the widget position
        void setPosition(const omega::Vector2f& value) { myPosition = value; }
        void setPosition(int value, int dimension) { myPosition[dimension] = value; }
		// Convenience method to center the widget around the specified point.
		void setCenter(const omega::Vector2f& value);
        //! Sets the widget rotation
        //! @param value - the widget rotation in degrees
        void setRotation(float value) { myRotation = value; }
        //! Gets the widget position.
        float getRotation() { return myRotation; }
        //@}

        //! sets the widget scale.
        //void setScale(float value) { myScale = value; }
        //! Gets the widget scale.
        //float getScale() { return myScale; }

        //! Size constraints
        //@{
        //! Gets the widget size
        const Vector2f& getSize();
        //float getSize(Orientation orientation);
        float getWidth();
        float getHeight();
        //! Sets the widget size.
        void setSize(const Vector2f& value);
        void setWidth(float value);
        void setHeight(float value);
        const Vector2f& getMinimumSize();
        const Vector2f& getMaximumSize();
        void setMinimumSize(const Vector2f& value);
        int getMinimumWidth();
        int getMinimumHeight();
        void setMaximumSize(const Vector2f& value);
        int getMaximumWidth();
        int getMaximumHeight();
        void setMinimumWidth(float value);
        void setMinimumHeight(float value);
        void setMaximumWidth(float value);
        void setMaximumHeight(float value);
        void clearSizeConstaints();
        void setAutosize(bool value);
        bool getAutosize();
        //@}

        bool isVisible();
        void setVisible(bool value);
		
		bool isEnabled() { return myEnabled; }
		void setEnabled(bool value) { myEnabled = value; }

		bool isActive() { return myActive; }
		void setActive(bool value) 
		{
			myActive = value; 
			//if(myActive != value)
			{
				if(value) activate();
				else deactivate();
			}
			//ofmsg("Widget %1% active: %2%", %myId %value);
		} 

        //bool isUserMoveEnabled() { return myUserMoveEnabled; }
        //void setUserMoveEnabled(bool value) { myUserMoveEnabled = value; }
        
        //! Returns the unique Widget id.
        int getId();
        virtual void layout();

        void setStereo(bool value) { myStereo = value; }
        bool isStereo() { return myStereo; }

		bool isGamepadInteractionEnabled();
		bool isPointerInteractionEnabled();

		void setHorizontalNextWidget(Widget* value) { myHorizontalNextWidget = value; }
		Widget* getHorizontalNextWidget() { return myHorizontalNextWidget; }

		void setHorizontalPrevWidget(Widget* value) { myHorizontalPrevWidget = value; }
		Widget* getHorizontalPrevWidget() { return myHorizontalPrevWidget; }

		void setVerticalNextWidget(Widget* value) { myVerticalNextWidget = value; }
		Widget* getVerticalNextWidget() { return myVerticalNextWidget; }

		void setVerticalPrevWidget(Widget* value) { myVerticalPrevWidget = value; }
		Widget* getVerticalPrevWidget() { return myVerticalPrevWidget; }

        virtual void autosize(Renderer* r) {}
        virtual void updateSize(Renderer* r);

        //! Appearance
		//@{
		void setStyle(const String& style);
		String getStyleValue(const String& key, const String& defaultValue = "");
		void setStyleValue(const String& key, const String& value);
		void setScale(float value) { myScale = value; }
		float getScale() { return myScale; }
		void setAlpha(float value) { myAlpha = value; }
		float getAlpha() { return myAlpha; }
		void setBlendMode(BlendMode value) { myBlendMode = value; }
		BlendMode getBlendMode() { return myBlendMode; }
		//@}

		Layer getLayer() { return myLayer; }
		void setLayer(Layer layer) { myLayer = layer; }

		//! Returns true if the point is within this widget's bounding box.
		bool hitTest(const Vector2f& point);
        Vector2f transformPoint(const omega::Vector2f& point);

		void setUpdateCommand(const String& cmd) { myUpdateCommand = cmd; }
		String getUpdateCommand() { return myUpdateCommand; }

		template<typename W> static W* getSource(const Event& evt);

    protected:
        bool simpleHitTest(const omega::Vector2f& point);
        static bool simpleHitTest(const omega::Vector2f& point, const omega::Vector2f& pos, const omega::Vector2f& size);

		virtual void activate() {}
		virtual void deactivate() {}
		virtual void updateStyle();

        //! internal layout management
        //@{
        void requestLayoutRefresh();
        bool needLayoutRefresh();
        void setActualSize(int value, Orientation orientation, bool force = false);
        //@}

        void setContainer(Container* value);
		Container* getContainer() { return myContainer; }
        void dispatchUIEvent(const Event& evt);

		// Menu Widget Sounds
		void playMenuScrollSound();

    protected:
        omega::Vector2f myPosition;
        omega::Vector2f mySize;
        float myRotation;
        //float myScale;

    private:
		Layer myLayer;

        bool myStereo;
        bool myInitialized;

        Engine* myServer;

        static NameGenerator mysNameGenerator;

        unsigned int myId;
		// Widget links for button-based navigation
		Widget* myHorizontalNextWidget;
		Widget* myHorizontalPrevWidget;
		Widget* myVerticalPrevWidget;
		Widget* myVerticalNextWidget;

        omega::String myName;

		// We use a raw pointer to our parent in order to avoid reference loops.
        Container* myContainer;

        IEventListener* myEventHandler;
        Ref<UiScriptCommand> myUiEventCommand;

        bool myNeedLayoutRefresh;

        // Debug mode.
        bool myDebugModeEnabled;
        omega::Color myDebugModeColor;

        //bool myUserMoveEnabled;
        //bool myMoving;
        //omega::Vector2f myUserMovePosition;

		// When true, the widget is visible.
        bool myVisible;
		// When true, the widget is enabled, i.e. it can receive input events.
		bool myEnabled;
		// When true, the widget has active focus, i.e. it has processing priority over input events.
        bool myActive;

        // Size constraints.
        omega::Vector2f myMinimumSize;
        omega::Vector2f myMaximumSize;
        bool myAutosize;

		// Blend mode
		BlendMode myBlendMode;
		float myAlpha;
		float myScale;

		// Style data
		Dictionary<String, String> myStyleDictionary;

		// Fill style data
		bool myFillEnabled;
		Color myFillColor;

		// Border style data
		struct BorderStyle
		{
			void fromString(const String& str);

			Color color;
			int width;
		};

		String myUpdateCommand;

		BorderStyle myBorders[4];

		static ui::Widget* mysWidgets[MaxWidgets];
    };

    ///////////////////////////////////////////////////////////////////////////////////////////////
    class OTK_API WidgetRenderable: public Renderable
    {
    public:
        WidgetRenderable(Widget* owner): myOwner(owner) {}
        virtual void draw(const DrawContext& context);
        virtual void drawContent(const DrawContext& context);

    protected:
        virtual void preDraw();
        virtual void postDraw();
		void pushDrawAttributes();
		void popDrawAttributes();

        //! Gets the current renderstate (accessible inside drawContent)
        RenderState* getRenderState() { return myRenderState; }

    private:
        Widget* myOwner;
        RenderState* myRenderState;
    };

    ///////////////////////////////////////////////////////////////////////////////////////////////
    inline const String& Widget::getName() 
    { return myName; }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    inline void Widget::setName(const String& name)
    { myName = name; }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    inline IEventListener* Widget::getUIEventHandler() 
    { return myEventHandler; }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    inline void Widget::setUIEventHandler(IEventListener* value)
    { myEventHandler = value; }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    inline void Widget::setAutosize(bool value)
    { 
        myAutosize = value; 
        requestLayoutRefresh();
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    inline bool Widget::getAutosize()
    { return myAutosize; }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    inline const Vector2f& Widget::getSize() 
    { return mySize; }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    //inline float Widget::getSize(Orientation orientation)
    //{
    //    return mySize[orientation];
    //}

    ///////////////////////////////////////////////////////////////////////////////////////////////
    inline float Widget::getWidth()
    { return mySize[0]; }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    inline float Widget::getHeight() 
    { return mySize[1]; }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    inline void Widget::setSize(const omega::Vector2f& value) 
    { 
		if(value != mySize)
		{
			requestLayoutRefresh(); 
			mySize = value; 
			myMinimumSize = value; 
			myMaximumSize = value; 
		}
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    inline void Widget::setWidth(float value) 
    { 
        requestLayoutRefresh(); 
        mySize[0] = value; 
        myMinimumSize[0] = value; 
        myMaximumSize[0] = value; 
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    inline void Widget::setHeight(float value) 
    { 
        requestLayoutRefresh(); 
        mySize[1] = value; 
        myMinimumSize[1] = value; 
        myMaximumSize[1] = value; 
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    inline const Vector2f& Widget::getMinimumSize() 
    { return myMinimumSize; }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    inline const Vector2f& Widget::getMaximumSize() 
    { return myMaximumSize; }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    inline void Widget::setMinimumSize(const Vector2f& value) 
    {
        requestLayoutRefresh(); 
        myMinimumSize = value; 
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    inline int Widget::getMinimumWidth() 
    { return myMinimumSize[0]; }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    inline int Widget::getMinimumHeight() 
    { return myMinimumSize[1]; }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    inline void Widget::setMaximumSize(const Vector2f& value) 
    {
        requestLayoutRefresh(); 
        myMaximumSize = value; 
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    inline int Widget::getMaximumWidth() 
    { return myMaximumSize[0]; }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    inline int Widget::getMaximumHeight() 
    { return myMaximumSize[1]; }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    inline void Widget::setMinimumWidth(float value) 
    { 
        requestLayoutRefresh(); 
        myMinimumSize[0] = value; 
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    inline void Widget::setMinimumHeight(float value) 
    {
        requestLayoutRefresh(); 
        myMinimumSize[1] = value; 
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    inline void Widget::setMaximumWidth(float value) 
    { 
        requestLayoutRefresh(); 
        myMaximumSize[0] = value; 
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    inline void Widget::setMaximumHeight(float value) 
    { 
        requestLayoutRefresh(); 
        myMaximumSize[1] = value; 
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    inline bool Widget::isVisible() 
    { return myVisible; }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    inline void Widget::setVisible(bool value) 
    { myVisible = value; }

	///////////////////////////////////////////////////////////////////////////////////////////////
	// NOTE: Widget::getSource is only used by UiScriptCommand. See if there is a way to get rid of this.
	template<typename W> 
	inline W* Widget::getSource(const Event& evt)
	{
		if(evt.getServiceType() == Service::Ui)
		{
			W* w = dynamic_cast<W*>(mysWidgets[evt.getSourceId()]);
			return w;
		}
		return NULL;
	}
};
}; // namespace omegaToolkit

#endif