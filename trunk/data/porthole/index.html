<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset=utf-8 />
 <!--<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>-->
 <meta name="apple-mobile-web-app-capable" content="yes"/>
 <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
 <script src="./hammer.js"></script>
 <script src="./jquery.specialevent.hammer.js"></script>
 <title>Porthole</title>
</head>

<body>
<!--<h3>Detected Browser: <div id=brow>...</div></h3>-->
<table>
	<tr>
<!--		<td align=center><input type=button id=offset value="Reset counter" onclick="reset();" ></td>-->
		<td id=wsdi_statustd align=center><div id=wsdi_status>Not initialized</div></td>
        <td align=center><div id=porthole_drawing> </div></td>
	</tr>
</table>

<!--<img src="" id="frame" style="width:840px;height:480px"/>-->

<script>

    //////////////////////////////////////////////////////////////////////////////
    /* BrowserDetect came from http://www.quirksmode.org/js/detect.html */
    var BrowserDetect = {
        init: function () {
            this.browser = this.searchString(this.dataBrowser) || "An unknown browser";
            this.version = this.searchVersion(navigator.userAgent)
			|| this.searchVersion(navigator.appVersion)
			|| "an unknown version";
            this.OS = this.searchString(this.dataOS) || "an unknown OS";
        },
        searchString: function (data) {
            for (var i = 0; i < data.length; i++) {
                var dataString = data[i].string;
                var dataProp = data[i].prop;
                this.versionSearchString = data[i].versionSearch || data[i].identity;
                if (dataString) {
                    if (dataString.indexOf(data[i].subString) != -1)
                        return data[i].identity;
                }
                else if (dataProp)
                    return data[i].identity;
            }
        },
        searchVersion: function (dataString) {
            var index = dataString.indexOf(this.versionSearchString);
            if (index == -1) return;
            return parseFloat(dataString.substring(index + this.versionSearchString.length + 1));
        },
        dataBrowser: [
		{
		    string: navigator.userAgent,
		    subString: "Chrome",
		    identity: "Chrome"
		},
		{ string: navigator.userAgent,
		    subString: "OmniWeb",
		    versionSearch: "OmniWeb/",
		    identity: "OmniWeb"
		},
		{
		    string: navigator.vendor,
		    subString: "Apple",
		    identity: "Safari",
		    versionSearch: "Version"
		},
		{
		    prop: window.opera,
		    identity: "Opera",
		    versionSearch: "Version"
		},
		{
		    string: navigator.vendor,
		    subString: "iCab",
		    identity: "iCab"
		},
		{
		    string: navigator.vendor,
		    subString: "KDE",
		    identity: "Konqueror"
		},
		{
		    string: navigator.userAgent,
		    subString: "Firefox",
		    identity: "Firefox"
		},
		{
		    string: navigator.vendor,
		    subString: "Camino",
		    identity: "Camino"
		},
		{		// for newer Netscapes (6+)
		    string: navigator.userAgent,
		    subString: "Netscape",
		    identity: "Netscape"
		},
		{
		    string: navigator.userAgent,
		    subString: "MSIE",
		    identity: "Explorer",
		    versionSearch: "MSIE"
		},
		{
		    string: navigator.userAgent,
		    subString: "Gecko",
		    identity: "Mozilla",
		    versionSearch: "rv"
		},
		{ 		// for older Netscapes (4-)
		    string: navigator.userAgent,
		    subString: "Mozilla",
		    identity: "Netscape",
		    versionSearch: "Mozilla"
		}
	],
        dataOS: [
		{
		    string: navigator.platform,
		    subString: "Win",
		    identity: "Windows"
		},
		{
		    string: navigator.platform,
		    subString: "Mac",
		    identity: "Mac"
		},
		{
		    string: navigator.userAgent,
		    subString: "iPhone",
		    identity: "iPhone/iPod"
		},
		{
		    string: navigator.platform,
		    subString: "Linux",
		    identity: "Linux"
		}
	]

    };
    BrowserDetect.init();

    
    // JUST FOR TEST
//    document.getElementById("brow").textContent = " " + BrowserDetect.browser + " "
//	+ BrowserDetect.version + " " + BrowserDetect.OS + " ";

    ////////////////// WEBSCOKET AND CANVAS ////////////////////////////

    var canvas = document.createElement('canvas');
    ctx = canvas.getContext("2d");
    canvas.width = 840;
    canvas.height = 480;

    // TEST case: append cavas to body tag
    var _body = document.getElementsByTagName('body')[0];
    _body.appendChild(canvas);
    var img = new Image();

    function get_appropriate_ws_url() {
        /*
        * We open the websocket encrypted if this page came on an
        * https:// url itself, otherwise unencrypted
        */
        var pcol;
        var u = document.URL;

        if (u.substring(0, 5) == "https") {
            pcol = "wss://";
            u = u.substr(8);
        } else {
            pcol = "ws://";
            if (u.substring(0, 4) == "http")
                u = u.substr(7);
        }

        u = u.split('/');

        return pcol + u[0];
    }

    var socket_di;

    if (BrowserDetect.browser == "Firefox" && BrowserDetect.version < 12) {
        socket_di = new MozWebSocket(get_appropriate_ws_url(),
				   "porthole_websocket");
    } else {
        socket_di = new WebSocket(get_appropriate_ws_url(),
				   "porthole_websocket");
    }


    try {
        socket_di.onopen = function () {
            document.getElementById("wsdi_statustd").style.backgroundColor = "#40ff40";
            document.getElementById("wsdi_status").textContent = " websocket connection opened ";
        }

        socket_di.onmessage = function got_packet(msg) {
            //            document.getElementById("porthole_drawing").textContent = msg.data + "\n";

            image = "data:image/png;base64," + msg.data;
            img.src = image;

            ctx.drawImage(img, 0, 0);

        }

        socket_di.onclose = function () {
            document.getElementById("wsdi_statustd").style.backgroundColor = "#ff4040";
            document.getElementById("wsdi_status").textContent = " websocket connection CLOSED ";
        }
    } catch (exception) {
        alert('<p>Error' + exception);
    }

    function reset() {
        socket_di.send("reset\n");
    }

    //////////////////////////////////////////////////////////

    ////////////////// MULTITOUCH ////////////////////////////

    // Prevent scrolling
//    document.body.addEventListener('touchmove', function (event) {
//        event.preventDefault();
//    }, false);

    // Initialize hammer
    var hammer = new Hammer(canvas, {
            prevent_default: true,

            drag: true,
            drag_vertical: true,
            drag_horizontal: true,
            drag_min_distance: 0,

            transform: true,
            scale_treshold: 0.01,
            rotation_treshold: 1,

            tap: false,
            tap_double: false,
            hold: false
        });

    // Drag vars
    var dragging = false;
    var dragPosX, dragPosY, dragDistX, dragDistY;
    var deltaX, deltaY;
    
    // Pinch vars
    var pinching = false;
    var pinchScale, pinchRotation;
    var deltaRotation;

    // Drag functions
    function watchDrag() {
        if (!dragging || pinching || deltaX == null || deltaY == null || 
                deltaX == "null" || deltaY == "null") {
            return;
        }
        var JSONOEvent = {
            "event_type": "drag",
            "deltaX": deltaX,
            "deltaY": deltaY
        };
        socket_di.send(JSON.stringify(JSONOEvent));
    }

    hammer.ondragstart = function (ev) {
        dragging = true;
    };
    hammer.ondragend = function (ev) {
        dragging = false;
    };
    hammer.ondrag = function (ev) {

        deltaX = ev.distanceX - dragDistX;
        deltaY = ev.distanceY - dragDistY;

        dragPosX = ev.position.x;
        dragPosY = parseInt(ev.position.y); // y is floating by default, so cast it
        dragDistX = ev.distanceX;
        dragDistY = ev.distanceY;

    };

    hammer.onswipe = function (ev) { };

    hammer.ontap = function (ev) {};
    hammer.ondoubletap = function (ev) { };

    // Pinch functions
    function watchPinch() {
        if (!pinching || pinchScale == null || pinchRotation == null ||
                pinchScale == "null" || pinchRotation == "null") {
            return;
        }
        var JSONOEvent = {
            "event_type": "pinch",
            "scale": pinchScale,
            "rotation": deltaRotation,
        };
        socket_di.send(JSON.stringify(JSONOEvent));
    }
    hammer.ontransformstart = function (ev) { 
        dragging = false;
        pinching = true;
    };
    hammer.ontransformend = function (ev) {
        pinching = false;
    };
    hammer.ontransform = function (ev) { 
        dragging = false; // Avoid overlapping of drag and pinch events

        deltaRotation = parseFloat(pinchRotation - ev.rotation);

        pinchScale = parseFloat(ev.scale);
        pinchRotation = ev.rotation;

        //document.getElementById("porthole_drawing").textContent = "Pinch: scale = " + pinchScale + " rotation = "+ pinchRotation + " deltaRotation = "+ deltaRotation;
    };

    hammer.onrelease = function (ev) { };
    hammer.onhold = function (ev) { };

    ///////////////////////////////////////////////////////////

    // Dragging listening interval
    setInterval(watchDrag, 20);
    setInterval(watchPinch, 20);

</script>

</body>
</html>
