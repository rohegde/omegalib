#summary Python reference: module cyclops
#sidebar Sidebar

<p>*Last revision:* ver. 4.0 - 13 March 2013</p>*

<wiki:toc max_depth="2" />

= Module cyclops =
Cyclops is a utility library that sits on top of omegalib and OpenSceneGraph, and it is designed to simplify developement of applications that need to draw complex and visually pleasant scenes, without having to deal with the low-level details of osg. SOme of cyclops features are:
 * Support for loading scenes defined in a simple xml format
 * Easy creation of primitive shapes, like planes, spheres, cubes and so on
 * Out-of-the-box support for soft shadows
 * An expandable shaders and effects library
-------------------------------------------------------------------------------
==  Misc Functions ==

=== `getSceneManager()` ===
Returns a reference to the cyclops scene manager

-------------------------------------------------------------------------------
==  `class ProgramAsset` ==
Wraps the [http://omegalib.googlecode.com/svn/refdocs/trunk/html/classcyclops_1_1_program_asset.html cyclops::ProgramAsset] class. Represents a Gpu program source and its associated binary code.

-------------------------------------------------------------------------------
==  `class SceneManager` ==
Wraps the [http://omegalib.googlecode.com/svn/refdocs/trunk/html/classcyclops_1_1_scene_manager.html cyclops::SceneManager] C++ class. Manages a cyclops scene and its associated resources.

=== Methods ===
|| Method(s) || Description ||
|| *Backgrond* || ||
|| `setBackgroundColor(color)` || ||
|| `setSkyBox(skybox)` || ||
|| *Scene management* || ||
|| `loadModel(modelInfo)` || Loads a model defined by the data in `modelInfo` ||
|| `loadModelAsync(modelInfo, command)` || Queues a model for loading. Call the command in the `command` string when loading is done (successful or not) ||
|| `loadScene(path)` || Loads a cyclops xml scene file ||
|| `unload()` || Cleans the scene and releases all associated resources ||
|| *Wand* || ||
|| `displayWand(wandId, trackableId)` || Displays a wand (identified by `wandId`) and attaches it to a trackable object `trackableId` ||
|| `setWandEffect(wandId, effect)` || Sets the render effect for wand `wandId` ||
|| `setWandSize(width, height)` ||  ||
|| *Shadow support* || ||
|| `getMainLight()`, `setMainLight(light)` || Sets the main scene light. When shadow mapping is enabled, it will be used to cast shadows ||
|| `getCurrentShadowSettings()` || Gets the current settings for shadow mapping ||
|| `resetShadowSettings(settings)` || Resets the shadow settings. Can be used to turn shadow maps on and off, and to change their quality ||
|| *Shaders* || ||
|| `setShaderMacroToFile(macro, file)` || Sets the specified shader macro to the contents of a file. Appearances of the macro in any loaded shader will be replaced with the file contents. Example: <code>scene.setShaderMacroToFile('macro1', 'file.frag')</code> will substitute `@macro1` in shaders with the text from `file.frag` ||
|| `setShaderMacroToString(macro, string)` || Sets the specified shader macro to the specified string. Appearances of the macro in any loaded shader will be replaced with the string text. Example: <code>scene.setShaderMacroToFile('macro1', 'a = b + c')</code> will substitute `@macro1` in shaders with `a = b + c` ||
|| `createProgramFromString(name, vertexCode, fragmentCode)` || Creates a new Gpu Program using the vertex and fragment source code passed as parameters. Registers the program with the specified name, so it can be used in effect definitions. It aso returns the program as a `ProgramAsset` object. ||
|| `reloadAndRecompileShaders()` || Forces the shaders to be reloaded and recompiled from source ||
|| *Textures* || ||
|| `createTexture(name, pixels)` || Creates a texture with the specified name using the passed `PixelData` object. The texture can then be referenced in effect definitions. ||

-------------------------------------------------------------------------------
==  `class Uniform` ==
=== Methods ===
|| Method(s) || Description ||
|| `getType()` || Returns the uniform type. ||
|| `setInt(value)`, `getInt()` || ||
|| `setFloat(value)`, `getFloat()` || ||
|| `setVector2f(value)`, `getVector2f()` || ||
|| `setVector3f(value)`, `getVector3f()` || ||
|| `setVector4f(value)`, `getVector4f()` || ||

=== Uniform Types ===
Currently supported uniform types are listed in the `UniformType` enumeration:
	* `Float`
	* `Int`
	* `Vector2f`
	* `Vector3f`
	* `Vector4f`

-------------------------------------------------------------------------------
==  `class Uniforms` ==
=== Methods ===
|| Method(s) || Description ||
|| `addUniform(name, type)` ||  ||
|| `addUniformrray(name, type, numElements)` ||  ||
|| `getUniform(name)` ||  ||
|| `removeAllUniforms()` ||  ||

-------------------------------------------------------------------------------
==  `class Material` (extends `Uniforms`) ==
=== Methods ===
|| Method(s) || Description ||
|| `setDiffuseColor(color)` ||  ||
|| `setEmissiveColor(color)` ||  ||
|| `setTransparent(value)` `isTransparent()` ||  ||

-------------------------------------------------------------------------------
==  `class Entity` (extends `SceneNode`) ==
Wraps the [http://omegalib.googlecode.com/svn/refdocs/trunk/html/classcyclops_1_1_entity.html cyclops::Entity] C++ class. Entities are extended scene nodes that offer additional functionality for 3d model visualization, like transparency, rendering effects and link to motion capture tracked objects. Upon creation, entities are attached to the scene root, but they can be attached to different nodes in the scene after creation.

=== Methods ===
|| Method(s) || Description ||
|| `hasEffect()` || Returns true if an effect is set for the entity ||
|| `setEffect(effectDefinition)` || Sets the rendering effect for the entity ||
|| `getAlpha()`, `setAlpha(value)` || Gets or sets the transparency for the entity (between 0 and 1) ||
|| `followTrackable(trackabeId)` || Starts following the motion-captured trackable `trackableId` ||
|| `setFollowOffset(offset, orientationOffset)` || Sets the tracking position and orientation offset applied to this object, with respect to the motion captured trackable ||
|| `unfollow()` || Stops following a motion-captured trackable ||
|| *Context menu* || ||
|| `createContextMenu()` || Creates a context menu attached to this entity. When the user selectes the entity, the menu will pop up. Returns a `Menu` object ||
|| `getContextMenu()` || Gets the attached context menu for the entity if one has been set. ||
|| `deleteContextMenu()` || Deletes a context menu attached to this entity ||

-------------------------------------------------------------------------------
==  `class SphereShape` (extends `SphereShape`) ==
Wraps the [http://omegalib.googlecode.com/svn/refdocs/trunk/html/classcyclops_1_1_sphere_shape.html cyclops::SphereShape]. Defines a sphere that can be added to the scene

=== Methods ===
|| Method(s) || Description ||
|| `create(radius, subdivisions)` *static* || Returns true if an effect is set for the entity ||

=== Examples ===
==== Creation ====
{{{
	# Create a sphere with a radius on 1 meter, with a 4 subdivision level.
	s = SphereShape.create(1, 4)
	# Make the sphere half-transparent and move it
	s.getMaterial().setAlpha(0.5)
	s.setPosition(Vector3(0, 1.5, 0))
}}}

-------------------------------------------------------------------------------
==  `class PlaneShape` (extends `Entity`) ==
Wraps the [http://omegalib.googlecode.com/svn/refdocs/trunk/html/classcyclops_1_1_plane_shape.html cyclops::PlaneShape]. Defines a plane that can be added to the scene

=== Methods ===
|| Method(s) || Description ||
|| `create(width, height)` *static* || Creates a plane with the specified width and height, on the X-Y plane ||

-------------------------------------------------------------------------------
==  `class BoxShape` (extends `Entity`) ==
Wraps the [http://omegalib.googlecode.com/svn/refdocs/trunk/html/classcyclops_1_1_box_shape.html cyclops::BoxShape]. Defines a box that can be added to the scene

=== Methods ===
|| Method(s) || Description ||
|| `create(width, height, depth)` *static* || Creates a box with the specified width, height and depth ||

-------------------------------------------------------------------------------
==  `class CylinderShape` (extends `Entity`) ==
Wraps the [http://omegalib.googlecode.com/svn/refdocs/trunk/html/classcyclops_1_1_cylinder_shape.html cyclops::CylinderShape]. Defines a cylinder that can be added to the scene. Cylinder shapes have custom subdivision levels and different radii for their ends, allowing the user to create a variety of shapes (cylinder, pyramid, truncated pyramid, tetrahedron, etc).

=== Methods ===
|| Method(s) || Description ||
|| `create(length, radius1, radius2, subdivisions, sides)` *static* || Creates a new cylinder shape ||

-------------------------------------------------------------------------------
==  `class LineSet` (extends `Entity`) ==
Wraps the [http://omegalib.googlecode.com/svn/refdocs/trunk/html/classcyclops_1_1_line_set.html cyclops::LineSet]. Defines a container of 3D line primitives. Lines are drawn as cylinders. Using this class instead of the CylinderShape class is better if:
	* You have to draw lots of lines (or cylinders) that share the same material / effect
	* You want to place lines in the scene defining a start / end point and thickness (instead of position / orientation / scale)

=== Methods ===
|| Method(s) || Description ||
|| `create()` *static* || Creates a new LineSet object ||
|| `addLine()` || Creates a new line ||
|| `removeLine(line)` || Removes the specified line ||

`addLine()` returns an object of type `Line` that supports the following methods:
|| Method(s) || Description ||
|| `setStart(position)` || Sets the start position of the line (as a `Vector3`) ||
|| `setEnd(position)` || Sets the end position of the line (as a `Vector3`) ||
|| `getThickness()` `setThickness(value)` || Gets or sets the line thickness ||

-------------------------------------------------------------------------------
==  `class StaticObject` (extends `Entity`) ==
Wraps the [http://omegalib.googlecode.com/svn/refdocs/trunk/html/classcyclops_1_1_static_object.html cyclops::StaticObject]. Creates an object using a loaded 3d model

=== Methods ===
|| Method(s) || Description ||
|| `create(modelName)` *static* || Creates an object using a loaded model with the specified name ||

=== Examples ===
==== Sync model loading and creation ====
{{{
	# Load a torus model
	mi = ModelInfo()
	mi.name = "torus"
	mi.path = "cyclops/test/torus.fbx"
	scene.loadModel(mi)
	
	# Create a green torus
	t1 = StaticObject.create("torus")
	t1.setPosition(Vector3(-1, 0, 0))
	t1.setEffect("colored -d green")
	
	# Create a red torus
	t1 = StaticObject.create("torus")
	t1.setPosition(Vector3(1, 0, 0))
	t1.setEffect("colored -d red")
}}}

==== Async model loading and creation ====
{{{
	# Same as the previous example, but uses asynchronous loading
	mi = ModelInfo()
	mi.name = "torus"
	mi.path = "cyclops/test/torus.fbx"
	
	# After this call control returns immediately to the script.
	# onTorusLoaded() will be called once the model is done loading.
	scene.loadModelAsync(mi, "onTorusLoaded()")
	
	def onTorusLoaded():
		# Create a green torus
		t1 = StaticObject.create("torus")
		t1.setPosition(Vector3(-1, 0, 0))
		t1.setEffect("colored -d green")
		
		# Create a red torus
		t1 = StaticObject.create("torus")
		t1.setPosition(Vector3(1, 0, 0))
		t1.setEffect("colored -d red")
}}}

-------------------------------------------------------------------------------
==  `class AnimatedObject` (extends `Entity`) ==
Wraps the [http://omegalib.googlecode.com/svn/refdocs/trunk/html/classcyclops_1_1_animated_object.html cyclops::AnimatedObject]. Creates an object using a loaded 3d model. If the model contains animations, they can be played back through this class. Models using the Autodesk .fbx format are supported by default. `AnimatedObject` also supports loading a set of separate model files that can be played back in a flipbook-style animation.

=== Methods ===
|| Method(s) || Description ||
|| `create(modelName)` *static* || Creates an object using a loaded model with the specified name ||
|| `hasAnimations()` || Returns true if the object contains animations ||
|| `getNumAnimations()` ||  ||
|| `playAnimation(animId)` ||  ||
|| `loopAnimation(animId)` ||  ||
|| `pauseAnimation(animId)` ||  ||
|| `stopAllAnimations()` ||  ||
|| `getCurAnimation()` ||  ||
|| `getAnimationLength(animId)` ||  ||
|| `getAnimationStart(animId)` ||  ||
|| `setAnimationStart(animId)` ||  ||

-------------------------------------------------------------------------------
==  `class Light` (extends `SceneNode`) ==
Wraps the [http://omegalib.googlecode.com/svn/refdocs/trunk/html/classcyclops_1_1_light.html cyclops::Light]. Defines a light for a cyclops scene. After creation, lights are automatically attached to the scene root node.

=== Methods ===
|| Method(s) || Description ||
|| `create()` *static* || Creates a new light object ||
|| `setColor(color)` || Sets the diffuse color for this light ||
|| `setAmbient(color)` || Sets the ambient color for this light. Ambient color will be considered only for the main scene light (see `SceneManager.setMainLight`) ||
|| `isEnabled()`, `setEnabled(value)` || Gets or sets the light enabled value ||
|| `getSoftShadowJitter()`, `setSoftShadowJitter(value)` || Gets or sets soft shadow jitter value for this light. Used only for the main light when shadows are enabled ||
|| `getSoftShadowWidth()`, `setSoftShadowWidth(value)` || Gets or sets soft shadow width value for this light. Used only for the main light when shadows are enabled ||
|| `setAttenuation(consant, linear, quadratic)`, `getAttenuation()` || Sets or gets the light attenuation values. `getAttenuation()` returns the attenuation parameters as a `Vector3` object. ||
|| `setLightType(type)`, `getLightType()` || Sets or gets the light type ||
|| `setLightFunction(string)`, `getLightFunction()` || Sets or gets the light function ||
|| `setLightDirection(value)`, `getLightDirection()` || Sets or gets the light direction for Spot or Directional light types ||
|| `setSpotExponent(value)`, `getSpotExponent()` || Sets or gets the spot exponent for Spot lights ||
|| `setSpotCutoff(value)`, `getSpotCutoff()` || Sets or gets the spot cutoff for Spot lights ||

=== Light Types ===
The `setLightType()` method accepts a value from the `LightType` enumeration. Supported values are:
	* `Point`: for point lights
	* `Directional`: for directional lights
	* `Spot`: for spot lights
	* `Custom`: for custom lights

Custom lights allow the user to specify a custom, per pixel light function:
{{{
	scene = getSceneManager()
	
	// Use the customFragmentFunctions macro to inject code into fragment shaders.
	scene.setShaderMacroToString('customFragmentFunctions', '''
		customLightFunction(SurfaceData sd, LightData ld)
		{
			// Trivial example: return a fixed color regardless of light or surface properties
			return vec4(1, 0, 0, 0);
		}
	'''
	)
	
	light = Light.create()
	light.setType(lightType.Custom)
	light.setLightFunction('customLightFunction')
}}}

-------------------------------------------------------------------------------
==  `class ModelInfo` ==
Wraps the [http://omegalib.googlecode.com/svn/refdocs/trunk/html/classcyclops_1_1_model_info.html cyclops::ModelInfo]. Contains the name of a model to load and load options.

=== Properties ===
|| Properties || Description ||
|| `name` || The unique name for this model ||
|| `description` || A description for this model. Can be used in user interfaces ||
|| `generateNormals` || when set to `True`, cyclops will generate normals for the loaded model ||
|| `generateTangents` || when set to `True`, cyclops will generate tangents for the loaded model. Tangents are used for tangent space computations in bump shaders and effects ||
|| `numFiles` || If set to a value other than 1, cyclops will attempt to load multiple models the string `%1` in the model path will be substituded by a model index ||
|| `path` || The relative path to the model. File lookup follows the rules defined in [https://code.google.com/p/omegalib/wiki/Filesystem the filesystem page] ||
|| `size` || The size of the loaded model in meters. If left to 0, the original model size will be preserved ||
|| `optimize` || When set to `True` cyclops will perform some optimizations on the loaded model to increase rendering performance. This is a recommended setting. ||
|| `usePowerOfTwoTextures` || When set to `True` non-power-of-two textures will e converted to power of two. Can be usually left set to false. ||

-------------------------------------------------------------------------------
==  `class ShadowSettings` ==
Wraps the [http://omegalib.googlecode.com/svn/refdocs/trunk/html/classcyclops_1_1_shadow_settings.html cyclops::ShadowSettings]. Contains shadow setting for the scene

=== Properties ===
|| Properties || Description ||
|| `shadowsEnabled` || Set to `True` cyclops will render shadows using the main light as the shadow map reference light ||
|| `shadowsResolutionRation` ||  ||

-------------------------------------------------------------------------------
==  `class Skybox` ==
Wraps the [http://omegalib.googlecode.com/svn/refdocs/trunk/html/classcyclops_1_1_skybox.html cyclops::Skybox]. Defines a sky box for the scene, using a cube map texture

=== Methods ===
|| Method(s) || Description ||
|| `loadCubeMap(path, extension)` || loads a cube map using a set of six textures contained in the specified path ||

=== Examples ===
==== Basic example ====
{{{
	# Load a cube map and attach it to the scene
	# the textures in common/cubemaps/grid4 must be named
	# posx.png, posy.png, negx.png, negy.png, posz.png, negz.png
	skybox = Skybox()
	skybox.loadCubeMap("common/cubemaps/grid4", "png")
	getSceneManager().setSkyBox(skybox)
}}}