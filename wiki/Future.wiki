#summary omegalib Future plans for omegalib
#sidebar Sidebar

= omegalib 2.0 =

== Library Refactoring ==
Separate display and services code. 
	* `ocore` contains just input serives and basic omegalib functionality (like math & configuration support)
	* `odisplay` (or `omedia`? or just `omega`?) contains display services and the current engine
	* Unify Engine and basic Application classes	
	* Unify Camera and Observer
	* Streamline RenderPass flow
	* Direct openGL rendering is now supported through implementation of custom RenderPasses.
	* `outils` for sample utility classes that are not good enough to be part of odisplay
		* ReferenceBox
		* Box
		* PlyReader
		* BoundingSphere
		* etc.
	* move `libconfig` in `ocore`
	* Keep using seprate namespaces or just a single one (like `omega`)?

=== Revise Equalizer display system ===
	* There is probably a lot of redundancy in the initialization flow - inefficiency in the current way the Equalizer / application init flow works. Revise it.
	* *?* Render interlaced & side by side directly inside channel render function without relying on equalizer config and multiple equalizer draw calls
		* Would allow to work around some problems with equalizer
		* Would this lead to better performance?
	* create autogenerator of eq configurations using libconfig

=== Revise Event class ===
	* Zoom -> Scale
	* split: convert to Scale
	* Remove SplitStart / SplitEnd, RotateStart, RotateEnd
	* Remove DoubleClick
	* Remove MoveUp, Down, Etc. events?
	
== New oinputserver / NetService, new protocol ==
	* ?create a lightweight library that given observer info from netservice, a config file and a tile id, returns the corrent modelview and projection matrices
		* How to deal with stereo rendering?
		 * Not easy to do without modifying more deeply the rendering system of the target application. At the end of the day, the lighter solution is the current one - just stream observer position and orientation and let the target app do the rest.
	

== Refactor Event class, generic messaging support ==

== Multimachine / distributed app changes ==

== SAGE Integration ==
Send pixels to SAGE through SAIL. Options:
	* Integrate as separate display system (I would have to take care of doing off-axis projection and a bunch of other stuff) *NO*
	* Integrate on top of display system at:
		* omega/DisplaySystem level (more generic) 
		* oengine level (allows me to use Camera / RenderPass functionality)
		
Create `IFrameListener` interface.
Called by display system whenever a frame has finished rendering (per-client.) Gives back to the implementer enough info (i.e. a RenderTarget?) to
capture the framebuffer contents and do whatever with them.

DisplaySystem supports attaching a `IFrameListener`, but the same can be done on a camera *MOST FLEXIBLE SOLUTION*

Implement a `SailService` service class, deriving from `IFrameListener` as well. `SailService` can connect to SAGE through Sail, receive SAGE messages
and (if the application is a graphical application) register itself to the display system (or to a camera) to send pixel output to SAGE.

Starting / Stopping the service connects/disconnects to SAGE, so the application has control over the streaming.

Multiple sail service instances can create multiple windows on SAGE from the same omegalib application (i.e a Vtk app displaying multiple plots on a SAGE display)

Sail UI capabilities can be used to create a view + control panel on a SAGE display


== Memory management and statistics support ==
Add a way to collect info about memory leaks, allocations and timing statistics in the application. 
	* Allow those statistics to be viewed as an OSD (like the console)
	
== Other stuff ==
 * make osg & vtk data a downloadable package.
 * re-add vtk support
