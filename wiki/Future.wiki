#summary omegalib Future plans for omegalib
#sidebar Sidebar

= omegalib 2.0 =

== Library Refactoring ==
Separate display and services code. 
	* `ocore` contains just input serives and basic omegalib functionality (like math & configuration support)
	* `odisplay` (or `omedia`? or just `omega`?) contains display services and the current engine
	
== New oinputserver / NetService, new protocol ==

== Refactor Event class, generic messaging support ==

== Multimachine / distributed app changes ==
	
== SAGE Integration ==
Send pixels to SAGE through SAIL. Options:
	* Integrate as separate display system (I would have to take care of doing off-axis projection and a bunch of other stuff) *NO*
	* Integrate on top of display system at:
		* omega/DisplaySystem level (more generic) 
		* oengine level (allows me to use Camera / RenderPass functionality)
		
Create `IFrameListener` interface.
Called by display system whenever a frame has finished rendering (per-client.) Gives back to the implementer enough info (i.e. a RenderTarget?) to
capture the framebuffer contents and do whatever with them.

DisplaySystem supports attaching a `IFrameListener`, but the same can be done on a camera *MOST FLEXIBLE SOLUTION*

Implement a `SailService` service class, deriving from `IFrameListener` as well. `SailService` can connect to SAGE through Sail, receive SAGE messages
and (if the application is a graphical application) register itself to the display system (or to a camera) to send pixel output to SAGE.

Starting / Stopping the service connects/disconnects to SAGE, so the application has control over the streaming.

Multiple sail service instances can create multiple windows on SAGE from the same omegalib application (i.e a Vtk app displaying multiple plots on a SAGE display)

Sail UI capabilities can be used to create a view + control panel on a SAGE display
