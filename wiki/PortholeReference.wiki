#summary Porthole reference
#sidebar Sidebar

= Porthole development=
<p>*Last revision:* 5 Octoboer 2012
<font color=#ff0000> (This is a preliminary / work in progress document and may be incomplete)</font></p>

omegalib offers support for HTML5-capable browsers interactions. Specifically, the interface is multi-touchable, in order to support most of the hand helded devices, such as iPads, iPhones, Android tablets, and Android smartphones.

Moreover, the interfaces are tailored on application needs and on devices specifications, without writing any Javascript or JQuery code, but only through an XML file and an, optional, CSS file. 

An overview of the system implementation is given in the following figure.

-- TODO figure1 --

Basically, the Porthole Service creates a Server in a separate thread, that handles all the incoming connections. But all the steps between the XML description and the actual management of the different devices, including camera streaming and manipulations, are transparent to the application developer.

= Instruction =

If you want your application to expose an interface to all the HTML5-capable browsers, and, in particular, to most of the hand helded devices, you need to provide the following files:

 * A _.xml_ file, that specifies the elements and their disposition for the different types of devices
 * A _.css_ file, that may contain any CSS style you want to apply to the final interface; it is used to tweak the style of the elements, but it may be empty if you are satisfied with the basic style provided

Finally, you need to add the Porthole Service in your C++ or python application.

In the following sections we go deeper into:
 * Create the xml file
 * Create the css file
 * Start the Porthole Service

== Interfaces description: .xml file ==

The main idea of how to compose the XML file is given in the following figure.

-- TODO figure2 --

the XML is divided into two main branches. The first one specifies the number and type of GUI elements, that represent the main “blocks” of the GUI. The second branch is responsible for mapping the main blocks to the different types of devices that may want to connect to the application.
In particular, the gui_elements part contains how many global interface blocks as needed, that are divided into two type (a third, a GoogleMaps canvas is in testing).

==== HTML element ==== 
This type of element can include any html piece of code, such as a group of control buttons, sliders, and so on. JQuery Mobile support is available, thus one could for example specify Buttons, Sliders, Radio Buttons, and so on, simply using JQuery Mobile classes.
These elements represent an interface building block.

Notice that JQuery Mobile style will apply to all your elements, thus, if you do NOT want any style on a particular html tag (and all its children), add the following attribute:

{{{data-role:"none"}}}

==== CAMERA element ==== 
This type of element represents a camera stream element, that is a rectangular space, with touch gestures enabled, that visualizes a camera inside the 3D world.
A camera could be of two types:

 * Custom, that is a camera that can freely move inside the world, based on interface interactions
 * Default, that is the default 3D camera inside the CAVE; thus, any interactions in the Virtual Environment is reflected in the interface canvas, and viceversa.

====  Javascript events handlers binding ==== 
In the HTML elements, events handlers could be binded to application functionalities using either:

 * C++ functions binding: developer could bind an event handler to a C++ function in his application
 * Python code injection: developer could insert into the event handler code a complete piece of code in Python language

This functionalities is achieved using a dynamic creation of Javascript functions that uses WebSockets to send which event has been triggered and which C++ function or Python code to execute. In the following XML Description example, Python code has been injected directly into a button Javascript events handlers in order to move the camera (downward in this case).

{{{
onmousedown="camera=getCameraById(%id%); position=camera.getPosition(); position[1] -= 0.025; camera.setPosition(position);"  
}}}

Finally, the gui disposition part can be composed by any number of elements, with two required attributes each: __minWidth__ and __minHeight__. This means that the interface type is mapped to the closest matching case.

Moreover, each element must define two type of interfaces, a __Portrait__ and a __Landscape__ interface (which could be the same though). These elements have a required attribute that is __layout__, which could be __vertical__ or __horizontal__: the former, disposes the elements from top to bottom, the latter, disposes the elements from left to right.

Inside each one of these two elements, any gui_element previously declared could be inserted.

== Interfaces style: .css file ==

The usage of the .css file is straightforward: it is attached to the final html file that is run on the device, in order to be able to apply custom fine-grained style to the interface. An example is given in the Hello Porthole section.

== Start the service ==

This part differes either if the application is written in C++ or in Python.

==== C++ ====

If the application is written in C++, you must have a free port number, the xml file path, the css file path and a PortholeFunctionsBinder binder object.

The function binder is used if you want to map any Javascript event handler to a C++ function (remember that C++ language has no Reflection, so the map must be explicit). In the following example, 5 functions are added.

{{{
	// Functions Bind
	PortholeFunctionsBinder* binder = new PortholeFunctionsBinder();
	binder->addFunction("up(event)", &up);
	binder->addFunction("down(event)", &down);
	binder->addFunction("left(event)", &left);
	binder->addFunction("right(event)", &right);
	binder->addFunction("zoomSlider(event)", &zoomSlider);

	// Porthole initialize the porthole service
	PortholeService* service = new PortholeService();
	ServiceManager* svcManager = SystemManager::instance()->getServiceManager();
	svcManager->addService(service);

	string fullPath_xml;
	DataManager::findFile("porthole/porthello.xml", fullPath_xml);

	string fullPath_css;
	DataManager::findFile("porthole/porthello.css", fullPath_css);

	service->start(4080, (char*)fullPath_xml.c_str(), (char*)fullPath_css.c_str(), binder);

}}}

The functions definition is:

{{{
void up(PortholeEvent &ev){
	Vector3f myPosition = ev.sessionCamera->camera->getPosition();
	myPosition[1] += 0.025f;
	ev.sessionCamera->camera->setPosition(myPosition);
}

void down(PortholeEvent &ev){
	Vector3f myPosition = ev.sessionCamera->camera->getPosition();
	myPosition[1] -= 0.025f;
	ev.sessionCamera->camera->setPosition(myPosition);
}

void left(PortholeEvent &ev){
	Vector3f myPosition = ev.sessionCamera->camera->getPosition();
	myPosition[0] -= 0.025f;
	ev.sessionCamera->camera->setPosition(myPosition);
}

void right(PortholeEvent &ev){
	Vector3f myPosition = ev.sessionCamera->camera->getPosition();
	myPosition[0] += 0.025f;
	ev.sessionCamera->camera->setPosition(myPosition);
}
void zoomSlider(PortholeEvent &ev){
	Vector3f myPosition = ev.sessionCamera->camera->getPosition();
	myPosition[2] = atoi(ev.value.c_str())/100;
	ev.sessionCamera->camera->setPosition(myPosition);
}
}}}

Now, if we have a button that states, for example:

{{{
onmousedown="up(event)"  
}}}

each time a button is clicked in the browser, the C++ up(PortholeEvent &ev) function is called.

==== Python ====
