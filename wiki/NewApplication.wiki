#summary Creating an omegalib application
#sidebar Sidebar

<p>*Last revision:* ver. 2.1</p>

This page explains how to set up the build environment for an empty omegalib application. When using *omegaSource* on this page, we refer to the root directory of your source copy of omegalib. *omegaBuild* will be the root directory of your build.

When creating a new omegalib application, you have three options:
 * *Add it to the omegalib build*: This is the easiest solution. Your application would be under omegaSource/src/apps. Building omegalib would automatically build your application as well. This may not be desirable if you want to keep your application separate from the omegalib codebase (i.e. you are not one of the main developers)
 
 * *Create an external application using CMake*: This is still pretty easy to do. You would create a cmake file for your own application (this assumes you have basic knowledge of cmake) and use the FindOmegalib.cmake script under omegaSource/CMakeModules to link your application to your local omegalib build.
 
 * *Create an external application using a native build system directly (make, Visual Studio, etc.)*: Altough doable, this solution is not officially supported. You should really use CMake, and save yourself a few headaches. If you must choose this path the basic steps would be:
  * add omegaSource/include, omegaSource/ext/include and omegaBuild/include, omegaBuild/omicron/omicron/include to your compiler include paths
  * depending on build type and platform, link against libraries under omegaBuild/lib, omegaBuild/bin, omegaSource/ext/lib32, omegaSource/ext/lib64

This page only covers solutions 1 and 2.

= Solution 1: Adding an application to the omegalib build =
== Step 1: Create the application directory and CMake file ==
Under omegaSource/src/apps create a new folder named as your application (we will be calling it `myapp` from now on). Create an empty source file `myapp.cpp` and a cmake build file, `CMakeList.txt`. Put the following in the CMake file:
<code>
	add_executable(myapp myapp.cpp)
	set_target_properties(ohello PROPERTIES FOLDER apps)
	target_link_libraries(ohello omega)
</code>
`add_executable` defines a new executable target with `myapp.cpp` as the only source file.
`set_target_properties` is optional: it is only used when generating visual studio solutions, to put the executable in the apps solution folder.
`target_link_libraries` specifies link targets for the executable. For this basic example we are only linking agains `omega` Depending on the application you are developing, you may want to link against additional libraries, i.e. `omegaToolkit`, `omegaOsg`, `omegaVtk`.

== Step 2: Adding application code ==
To `myapp.cpp` add the following code:
<code language="c++">
	#include <omega.h>
	#include <omegaGl.h>

	using namespace omega;

	class HelloApplication: public ServerModule
	{
	public:
		HelloApplication() {}
		virtual ~HelloApplication() {}
	};

	int main(int argc, char** argv)
	{
		Application<HelloApplication> app("myapp");
		return omain(app, argc, argv);
	}
</code>
*NOTE:* the `Application` object created in `main` takes one string parameter. This string parameter *must be the same as the application name*. If you specify anything different, your application won't work when run in cluster mode.

The code above is the most basic omegalib application possible. It will do nothing more than initializing the various omegalib subsystems and open an empty render window. Creating an application that actually does something is covered in other wiki pages.

== Step 3: Adding the application to the omegalib build ==
Now you need to make the main omegalib build aware of our new application. Go to omegaSource/src and open the `CMakeLists.txt` file you find there.


= Solution 2: Building an external application =