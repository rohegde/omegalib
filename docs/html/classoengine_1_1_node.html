<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>omegalib: oengine::Node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceoengine.html">oengine</a>      </li>
      <li><a class="el" href="classoengine_1_1_node.html">oengine::Node</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>oengine::Node Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="oengine::Node" --><!-- doxytag: inherits="omega::DynamicObject" -->
<p>Class representing a general-purpose node an articulated scene graph.  
<a href="#_details">More...</a></p>
<div class="dynheader">
Inheritance diagram for oengine::Node:</div>
<div class="dyncontent">
<div class="center"><img src="classoengine_1_1_node__inherit__graph.png" border="0" usemap="#oengine_1_1_node_inherit__map" alt="Inheritance graph"/></div>
<map name="oengine_1_1_node_inherit__map" id="oengine_1_1_node_inherit__map">
<area shape="rect" id="node5" href="classoengine_1_1_scene_node.html" title="oengine::SceneNode" alt="" coords="13,160,155,189"/><area shape="rect" id="node2" href="classomega_1_1_dynamic_object.html" title="omega::DynamicObject" alt="" coords="5,5,163,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classoengine_1_1_node-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a54449e99f7265401c2e8fa53ae66be15">TransformSpace</a> { <a class="el" href="classoengine_1_1_node.html#a54449e99f7265401c2e8fa53ae66be15ad435dd919778df588bd62a5394a83d2d">TransformLocal</a>, 
<a class="el" href="classoengine_1_1_node.html#a54449e99f7265401c2e8fa53ae66be15a290f7b922bb9cc16b573270b40e356ef">TransformParent</a>, 
<a class="el" href="classoengine_1_1_node.html#a54449e99f7265401c2e8fa53ae66be15ade666a7c2baac812f4775dd154aae080">TransformWorld</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Enumeration denoting the spaces which a transform can be relative to. </p>
 <a href="classoengine_1_1_node.html#a54449e99f7265401c2e8fa53ae66be15">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classomega_1_1_dictionary.html">Dictionary</a>&lt; <a class="el" href="namespaceomega.html#a39676bdac3c610b014bda97c88a94083">String</a>, <br class="typebreak"/>
<a class="el" href="classoengine_1_1_node.html">Node</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#ab050de779a0dc14bb1b920a4b7b8fbce">ChildNodeMap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classoengine_1_1_child_node.html">ChildNode</a>&lt; <a class="el" href="classoengine_1_1_node.html">Node</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#aaf376a3fb464e30eb881c749295fff83">Child</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::pair<br class="typebreak"/>
&lt; ChildNodeMap::iterator, <br class="typebreak"/>
ChildNodeMap::iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a8a96abed8ee68282024729925216aa57">ChildNodeRange</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::pair<br class="typebreak"/>
&lt; ChildNodeMap::const_iterator, <br class="typebreak"/>
ChildNodeMap::const_iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#abda68a9b598fd3c702d9cc5c646b7782">ConstChildNodeRange</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#ad7a34779cad45d997bfd6d3d8043c75f">Node</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor, should only be called by parent, not directly.  <a href="#ad7a34779cad45d997bfd6d3d8043c75f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#abc80390991fd1d39a91fc242ef48acff">Node</a> (const <a class="el" href="namespaceomega.html#a39676bdac3c610b014bda97c88a94083">String</a> &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor, should only be called by parent, not directly.  <a href="#abc80390991fd1d39a91fc242ef48acff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#aa0840c3cb5c7159be6d992adecd2097c">~Node</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceomega.html#a39676bdac3c610b014bda97c88a94083">String</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#ae4c4b3e59bd1bb71938bc2d9dd03d854">getName</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the name of the node.  <a href="#ae4c4b3e59bd1bb71938bc2d9dd03d854"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classoengine_1_1_node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a6bbbaa13612a795cf99c6f4cdd749ab2">getParent</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets this node's parent (NULL if this is the root).  <a href="#a6bbbaa13612a795cf99c6f4cdd749ab2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classomega_1_1math_1_1quaternion.html">Quaternion</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a283ad23df5d5f242124ddde24978b750">getOrientation</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a quaternion representing the nodes orientation.  <a href="#a283ad23df5d5f242124ddde24978b750"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a13ab180dc837777519e338bc4d03f9b0">setOrientation</a> (const <a class="el" href="classomega_1_1math_1_1quaternion.html">Quaternion</a> &amp;q)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the orientation of this node via a quaternion.  <a href="#a13ab180dc837777519e338bc4d03f9b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a7cc8794fe7a3c0f9dc45415aaeed8b12">setOrientation</a> (float w, float x, float y, float z)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the orientation of this node via quaternion parameters.  <a href="#a7cc8794fe7a3c0f9dc45415aaeed8b12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#aa51b83655c10fc6286043e389c2d8164">resetOrientation</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets the nodes orientation (local axes as world axes, no rotation).  <a href="#aa51b83655c10fc6286043e389c2d8164"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#ac1003c7557c52ec7577a83f582bd493d">setPosition</a> (const <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> &amp;pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the position of the node relative to it's parent.  <a href="#ac1003c7557c52ec7577a83f582bd493d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#ad9899110e543c6b16997512e47c142c9">setPosition</a> (float x, float y, float z)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the position of the node relative to it's parent.  <a href="#ad9899110e543c6b16997512e47c142c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#aa622e5d30fda76de12196213a991dbc5">getPosition</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the position of the node relative to it's parent.  <a href="#aa622e5d30fda76de12196213a991dbc5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a6769cc1b09a34b9b8ab7b49b2232b1cb">setScale</a> (const <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> &amp;scale)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the scaling factor applied to this node.  <a href="#a6769cc1b09a34b9b8ab7b49b2232b1cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a125dcc8deb6d08a2f7b6794453c47e9a">setScale</a> (float x, float y, float z)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the scaling factor applied to this node.  <a href="#a125dcc8deb6d08a2f7b6794453c47e9a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a3b96c4807eb588ca98501ba9e55bb102">getScale</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the scaling factor of this node.  <a href="#a3b96c4807eb588ca98501ba9e55bb102"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a4a9ea1aa33df4b47b0e88e37ab95c3f9">setInheritOrientation</a> (bool inherit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells the node whether it should inherit orientation from it's parent node.  <a href="#a4a9ea1aa33df4b47b0e88e37ab95c3f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a4d08daa0534eb9163fe737762a03f779">getInheritOrientation</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this node is affected by orientation applied to the parent node.  <a href="#a4d08daa0534eb9163fe737762a03f779"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a08ab23ea9bb1b71ba28f18e0fef1569a">setInheritScale</a> (bool inherit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells the node whether it should inherit scaling factors from it's parent node.  <a href="#a08ab23ea9bb1b71ba28f18e0fef1569a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a6c80249647c02b895455e60124f197aa">getInheritScale</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this node is affected by scaling factors applied to the parent node.  <a href="#a6c80249647c02b895455e60124f197aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a76397bf505156bfa7f0f6daf072446b4">scale</a> (const <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> &amp;scale)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales the node, combining it's current scale with the passed in scaling factor.  <a href="#a76397bf505156bfa7f0f6daf072446b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a516253fce2a299665b26d664a3dd7735">scale</a> (float x, float y, float z)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales the node, combining it's current scale with the passed in scaling factor.  <a href="#a516253fce2a299665b26d664a3dd7735"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#ac342819f2821de82cb841ff95e22f880">translate</a> (const <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> &amp;d, <a class="el" href="classoengine_1_1_node.html#a54449e99f7265401c2e8fa53ae66be15">TransformSpace</a> relativeTo=TransformParent)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the node along the Cartesian axes.  <a href="#ac342819f2821de82cb841ff95e22f880"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a44f4daf23a85bded31903a6245bfb4a4">translate</a> (float x, float y, float z, <a class="el" href="classoengine_1_1_node.html#a54449e99f7265401c2e8fa53ae66be15">TransformSpace</a> relativeTo=TransformParent)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the node along the Cartesian axes.  <a href="#a44f4daf23a85bded31903a6245bfb4a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#aa10278966cbe55dbaa393e1f5184da64">translate</a> (const <a class="el" href="classomega_1_1math_1_1matrix.html">Matrix3f</a> &amp;axes, const <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> &amp;move, <a class="el" href="classoengine_1_1_node.html#a54449e99f7265401c2e8fa53ae66be15">TransformSpace</a> relativeTo=TransformParent)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the node along arbitrary axes.  <a href="#aa10278966cbe55dbaa393e1f5184da64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a55dab67b1ccce531bf19d0c51181f4e6">translate</a> (const <a class="el" href="classomega_1_1math_1_1matrix.html">Matrix3f</a> &amp;axes, float x, float y, float z, <a class="el" href="classoengine_1_1_node.html#a54449e99f7265401c2e8fa53ae66be15">TransformSpace</a> relativeTo=TransformParent)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the node along arbitrary axes.  <a href="#a55dab67b1ccce531bf19d0c51181f4e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a6e3b4139e301abd98e0f34d026797db5">roll</a> (const float &amp;angle, <a class="el" href="classoengine_1_1_node.html#a54449e99f7265401c2e8fa53ae66be15">TransformSpace</a> relativeTo=TransformLocal)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate the node around the Z-axis.  <a href="#a6e3b4139e301abd98e0f34d026797db5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#adf779c06f0bbe3616c4515ddc6856db2">pitch</a> (const float &amp;angle, <a class="el" href="classoengine_1_1_node.html#a54449e99f7265401c2e8fa53ae66be15">TransformSpace</a> relativeTo=TransformLocal)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate the node around the X-axis.  <a href="#adf779c06f0bbe3616c4515ddc6856db2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a5849b42a4239ff95574e5910b25aa6a5">yaw</a> (const float &amp;angle, <a class="el" href="classoengine_1_1_node.html#a54449e99f7265401c2e8fa53ae66be15">TransformSpace</a> relativeTo=TransformLocal)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate the node around the Y-axis.  <a href="#a5849b42a4239ff95574e5910b25aa6a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a3f60558c0dab25655e8c6a0f3d2c26ab">rotate</a> (const <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> &amp;axis, const float &amp;angle, <a class="el" href="classoengine_1_1_node.html#a54449e99f7265401c2e8fa53ae66be15">TransformSpace</a> relativeTo=TransformLocal)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate the node around an arbitrary axis.  <a href="#a3f60558c0dab25655e8c6a0f3d2c26ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#af5c1c904284aa895e1631ac3f9a226c7">rotate</a> (const <a class="el" href="classomega_1_1math_1_1quaternion.html">Quaternion</a> &amp;q, <a class="el" href="classoengine_1_1_node.html#a54449e99f7265401c2e8fa53ae66be15">TransformSpace</a> relativeTo=TransformLocal)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate the node around an aritrary axis using a Quarternion.  <a href="#af5c1c904284aa895e1631ac3f9a226c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classomega_1_1math_1_1matrix.html">Matrix3f</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#aac21f9d5bedf6bd5f26909c5ed5d079c">getLocalAxes</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a matrix whose columns are the local axes based on the nodes orientation relative to it's parent.  <a href="#aac21f9d5bedf6bd5f26909c5ed5d079c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a132699398b350e83b548a5645e69beb0">addChild</a> (<a class="el" href="classoengine_1_1_node.html">Node</a> *child)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a (precreated) child scene node to this node.  <a href="#a132699398b350e83b548a5645e69beb0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#ae8e9c1b334429fdb83b891cbcc51349e">numChildren</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reports the number of child nodes under this one.  <a href="#ae8e9c1b334429fdb83b891cbcc51349e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classoengine_1_1_node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#af01f5814115581c55ef5b8c08a8020dc">getChild</a> (unsigned short index) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a pointer to a child node.  <a href="#af01f5814115581c55ef5b8c08a8020dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classoengine_1_1_node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a564866c72a3ca1b824804711e1ba5a8e">getChild</a> (const <a class="el" href="namespaceomega.html#a39676bdac3c610b014bda97c88a94083">String</a> &amp;name) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a pointer to a named child node.  <a href="#a564866c72a3ca1b824804711e1ba5a8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classoengine_1_1_node.html#a8a96abed8ee68282024729925216aa57">ChildNodeRange</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a2a766074721094059081a7d94f88e3f0">getChildren</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves an iterator for efficiently looping through all children of this node.  <a href="#a2a766074721094059081a7d94f88e3f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classoengine_1_1_node.html#abda68a9b598fd3c702d9cc5c646b7782">ConstChildNodeRange</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#ac5c725178891f63f4268d462f2b9ca22">getChildren</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves an iterator for efficiently looping through all children of this node.  <a href="#ac5c725178891f63f4268d462f2b9ca22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classoengine_1_1_node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#aabae61b372af0f21c2d779126561e997">removeChild</a> (unsigned short index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drops the specified child from this node.  <a href="#aabae61b372af0f21c2d779126561e997"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classoengine_1_1_node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#ab53dd6926b0e922b8ed671d9cda1be7b">removeChild</a> (<a class="el" href="classoengine_1_1_node.html">Node</a> *child)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drops the specified child from this node.  <a href="#ab53dd6926b0e922b8ed671d9cda1be7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classoengine_1_1_node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a59de321fe407af320e4ff145f0a304fb">removeChild</a> (const <a class="el" href="namespaceomega.html#a39676bdac3c610b014bda97c88a94083">String</a> &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drops the named child from this node.  <a href="#a59de321fe407af320e4ff145f0a304fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#acafef630e549df6bcc439975c4fbefa5">removeAllChildren</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all child Nodes attached to this node.  <a href="#acafef630e549df6bcc439975c4fbefa5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#ac51ec82eb287dd044c49b7f0e3468399">_setDerivedPosition</a> (const <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> &amp;pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the final world position of the node directly.  <a href="#ac51ec82eb287dd044c49b7f0e3468399"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a7f307f4db1ed12de20502e3c80f38296">_setDerivedOrientation</a> (const <a class="el" href="classomega_1_1math_1_1quaternion.html">Quaternion</a> &amp;q)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the final world orientation of the node directly.  <a href="#a7f307f4db1ed12de20502e3c80f38296"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classomega_1_1math_1_1quaternion.html">Quaternion</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#abb87f0ae54132573e7b786c8415cf738">getDerivedOrientation</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the orientation of the node as derived from all parents.  <a href="#abb87f0ae54132573e7b786c8415cf738"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a23a511816193475645b32d819705a3a9">getDerivedPosition</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the position of the node as derived from all parents.  <a href="#a23a511816193475645b32d819705a3a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#ad519b253d070fb5c8ab8ff33585fa251">getDerivedScale</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the scaling factor of the node as derived from all parents.  <a href="#ad519b253d070fb5c8ab8ff33585fa251"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classomega_1_1math_1_1transform.html">AffineTransform3</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a46620526683ba6fd76a3669bdf46ab9f">getFullTransform</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the full transformation matrix for this node.  <a href="#a46620526683ba6fd76a3669bdf46ab9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#ae3541d1bf654e3d7788aae3021adba64">update</a> (bool updateChildren, bool parentHasChanged)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method to update the <a class="el" href="classoengine_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>.  <a href="#ae3541d1bf654e3d7788aae3021adba64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a2fc2f74f73811c39d3db4650063e7697">convertWorldToLocalPosition</a> (const <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> &amp;worldPos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the local position, relative to this node, of the given world-space position.  <a href="#a2fc2f74f73811c39d3db4650063e7697"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a896cf7cdd883bb9f358b31c4887218a5">convertLocalToWorldPosition</a> (const <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> &amp;localPos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the world position of a point in the node local space useful for simple transforms that don't require a child node.  <a href="#a896cf7cdd883bb9f358b31c4887218a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classomega_1_1math_1_1quaternion.html">Quaternion</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#aec2034e74729a7651383db2c4b292cfc">convertWorldToLocalOrientation</a> (const <a class="el" href="classomega_1_1math_1_1quaternion.html">Quaternion</a> &amp;worldOrientation)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the local orientation, relative to this node, of the given world-space orientation.  <a href="#aec2034e74729a7651383db2c4b292cfc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classomega_1_1math_1_1quaternion.html">Quaternion</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#ac6eb73a591d1c7b7b4e0c7f030c7aa5d">convertLocalToWorldOrientation</a> (const <a class="el" href="classomega_1_1math_1_1quaternion.html">Quaternion</a> &amp;localOrientation)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the world orientation of an orientation in the node local space useful for simple transforms that don't require a child node.  <a href="#ac6eb73a591d1c7b7b4e0c7f030c7aa5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#abdf9e4efde4e839e611080aa6522e49d">needUpdate</a> (bool forceParentUpdate=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To be called in the event of transform changes to this node that require it's recalculation.  <a href="#abdf9e4efde4e839e611080aa6522e49d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#aeabf6c5a2d88d38586a01897da70bf7a">requestUpdate</a> (<a class="el" href="classoengine_1_1_node.html">Node</a> *child, bool forceParentUpdate=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by children to notify their parent that they need an update.  <a href="#aeabf6c5a2d88d38586a01897da70bf7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#ad6aea1f4b27416f969b890c093e975e3">cancelUpdate</a> (<a class="el" href="classoengine_1_1_node.html">Node</a> *child)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by children to notify their parent that they no longer need an update.  <a href="#ad6aea1f4b27416f969b890c093e975e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#aca8d4cdafb6b8c092db04636e3e02f46">getUserData</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a59fa62cd44bf4579401e29d73b3ece26">setUserData</a> (void *data)</td></tr>
<tr><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; <a class="el" href="classoengine_1_1_node.html">Node</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#af48f70359ff07e35a7600418d52abfe0">ChildUpdateSet</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#ab5f0786bcb59591c528efb0b776797fc">setParent</a> (<a class="el" href="classoengine_1_1_node.html">Node</a> *parent)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Only available internally - notification of parent.  <a href="#ab5f0786bcb59591c528efb0b776797fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a96d6e9970e1330f0c7b3e990ea5b3556">updateFromParent</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class-specific implementation of updateFromParent.  <a href="#a96d6e9970e1330f0c7b3e990ea5b3556"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoengine_1_1_node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#abe598ebd5ecaa51fa224e176a8f5d92a">mParent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classoengine_1_1_pointer.html">Pointer</a> to parent node.  <a href="#abe598ebd5ecaa51fa224e176a8f5d92a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classomega_1_1_dictionary.html">ChildNodeMap</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#aa315555b79e175c3b22c7b312d12053d">mChildren</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collection of pointers to direct children; hashmap for efficiency.  <a href="#aa315555b79e175c3b22c7b312d12053d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoengine_1_1_node.html#af48f70359ff07e35a7600418d52abfe0">ChildUpdateSet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a13e261a92137e13298729346a82a019c">mChildrenToUpdate</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of children which need updating, used if self is not out of date but children are.  <a href="#a13e261a92137e13298729346a82a019c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a08095d9783d4b1d141f5bc02028e9f56">mNeedParentUpdate</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag to indicate own transform from parent is out of date.  <a href="#a08095d9783d4b1d141f5bc02028e9f56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a099588575a4f0aca8985fda435c7e560">mNeedChildUpdate</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag indicating that all children need to be updated.  <a href="#a099588575a4f0aca8985fda435c7e560"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a0bd03111048bc671491fa232ad514312">mParentNotified</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag indicating that parent has been notified about update request.  <a href="#a0bd03111048bc671491fa232ad514312"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a1db450f68bcb28701c83b4282a20110d">mQueuedForUpdate</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag indicating that the node has been queued for update.  <a href="#a1db450f68bcb28701c83b4282a20110d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceomega.html#a39676bdac3c610b014bda97c88a94083">String</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a9748e38c6e97c5eec5614e8ce169a22f">mName</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Friendly name of this node, can be automatically generated if you don't care.  <a href="#a9748e38c6e97c5eec5614e8ce169a22f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classomega_1_1math_1_1quaternion.html">Quaternion</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a1800d35b28a18939dddba18a0fc6cb93">mOrientation</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores the orientation of the node relative to it's parent.  <a href="#a1800d35b28a18939dddba18a0fc6cb93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a96c2cbc83bbcd789e128233a43db1c50">mPosition</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores the position/translation of the node relative to its parent.  <a href="#a96c2cbc83bbcd789e128233a43db1c50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a7e37a9366ee71f2d85d75349f50b144f">mScale</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores the scaling factor applied to this node.  <a href="#a7e37a9366ee71f2d85d75349f50b144f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#ae02f1d7101c18caf1133b01af8f29300">mInheritOrientation</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores whether this node inherits orientation from it's parent.  <a href="#ae02f1d7101c18caf1133b01af8f29300"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a31a2e3c14ce154f265ef089568ed58be">mInheritScale</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores whether this node inherits scale from it's parent.  <a href="#a31a2e3c14ce154f265ef089568ed58be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a6a026cb0dfbb5e855ff6d1103a0693f2">myUserData</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classomega_1_1math_1_1quaternion.html">Quaternion</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#ab3edb6ec78b739e6c6bec89dd102325d">mDerivedOrientation</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cached combined orientation.  <a href="#ab3edb6ec78b739e6c6bec89dd102325d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#ad544fd680104b680e0acc5451126980c">mDerivedPosition</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cached combined position.  <a href="#ad544fd680104b680e0acc5451126980c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#ae53b20e9a311e2ef6b9fdb81265253a6">mDerivedScale</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cached combined scale.  <a href="#ae53b20e9a311e2ef6b9fdb81265253a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classomega_1_1math_1_1transform.html">AffineTransform3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#ae1584f0e1d57ab1030aac671f7aaa79f">mCachedTransform</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cached derived transform as a 4x4 matrix.  <a href="#ae1584f0e1d57ab1030aac671f7aaa79f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#aaad079ece87a65947783b57aa0a661df">mCachedTransformOutOfDate</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classomega_1_1_name_generator.html">NameGenerator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoengine_1_1_node.html#a36abee23a90b97fa3b833ed1fd39bf44">msNameGenerator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Incremented count for next name extension.  <a href="#a36abee23a90b97fa3b833ed1fd39bf44"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Class representing a general-purpose node an articulated scene graph. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>A node in the scene graph is a node in a structured tree. A node contains information about the transformation which will apply to it and all of it's children. Child nodes can have transforms of their own, which are combined with their parent's transformations. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This is an abstract class - concrete classes are based on this for specific purposes, e.g. <a class="el" href="classoengine_1_1_scene_node.html">SceneNode</a>, Bone </dd></dl>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="aaf376a3fb464e30eb881c749295fff83"></a><!-- doxytag: member="oengine::Node::Child" ref="aaf376a3fb464e30eb881c749295fff83" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classoengine_1_1_child_node.html">ChildNode</a>&lt;<a class="el" href="classoengine_1_1_node.html">Node</a>&gt; <a class="el" href="classoengine_1_1_child_node.html">oengine::Node::Child</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classoengine_1_1_scene_node.html#a1812810475956424cd305b2a48c6afcb">oengine::SceneNode</a>.</p>

</div>
</div>
<a class="anchor" id="ab050de779a0dc14bb1b920a4b7b8fbce"></a><!-- doxytag: member="oengine::Node::ChildNodeMap" ref="ab050de779a0dc14bb1b920a4b7b8fbce" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classomega_1_1_dictionary.html">Dictionary</a>&lt;<a class="el" href="namespaceomega.html#a39676bdac3c610b014bda97c88a94083">String</a>, <a class="el" href="classoengine_1_1_node.html">Node</a>*&gt; <a class="el" href="classomega_1_1_dictionary.html">oengine::Node::ChildNodeMap</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8a96abed8ee68282024729925216aa57"></a><!-- doxytag: member="oengine::Node::ChildNodeRange" ref="a8a96abed8ee68282024729925216aa57" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt; ChildNodeMap::iterator, ChildNodeMap::iterator&gt; <a class="el" href="classoengine_1_1_node.html#a8a96abed8ee68282024729925216aa57">oengine::Node::ChildNodeRange</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af48f70359ff07e35a7600418d52abfe0"></a><!-- doxytag: member="oengine::Node::ChildUpdateSet" ref="af48f70359ff07e35a7600418d52abfe0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;<a class="el" href="classoengine_1_1_node.html">Node</a>*&gt; <a class="el" href="classoengine_1_1_node.html#af48f70359ff07e35a7600418d52abfe0">oengine::Node::ChildUpdateSet</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abda68a9b598fd3c702d9cc5c646b7782"></a><!-- doxytag: member="oengine::Node::ConstChildNodeRange" ref="abda68a9b598fd3c702d9cc5c646b7782" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt; ChildNodeMap::const_iterator, ChildNodeMap::const_iterator&gt; <a class="el" href="classoengine_1_1_node.html#abda68a9b598fd3c702d9cc5c646b7782">oengine::Node::ConstChildNodeRange</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a54449e99f7265401c2e8fa53ae66be15"></a><!-- doxytag: member="oengine::Node::TransformSpace" ref="a54449e99f7265401c2e8fa53ae66be15" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classoengine_1_1_node.html#a54449e99f7265401c2e8fa53ae66be15">oengine::Node::TransformSpace</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enumeration denoting the spaces which a transform can be relative to. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a54449e99f7265401c2e8fa53ae66be15ad435dd919778df588bd62a5394a83d2d"></a><!-- doxytag: member="TransformLocal" ref="a54449e99f7265401c2e8fa53ae66be15ad435dd919778df588bd62a5394a83d2d" args="" -->TransformLocal</em>&nbsp;</td><td>
<p>Transform is relative to the local space. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a54449e99f7265401c2e8fa53ae66be15a290f7b922bb9cc16b573270b40e356ef"></a><!-- doxytag: member="TransformParent" ref="a54449e99f7265401c2e8fa53ae66be15a290f7b922bb9cc16b573270b40e356ef" args="" -->TransformParent</em>&nbsp;</td><td>
<p>Transform is relative to the space of the parent node. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a54449e99f7265401c2e8fa53ae66be15ade666a7c2baac812f4775dd154aae080"></a><!-- doxytag: member="TransformWorld" ref="a54449e99f7265401c2e8fa53ae66be15ade666a7c2baac812f4775dd154aae080" args="" -->TransformWorld</em>&nbsp;</td><td>
<p>Transform is relative to world space. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad7a34779cad45d997bfd6d3d8043c75f"></a><!-- doxytag: member="oengine::Node::Node" ref="ad7a34779cad45d997bfd6d3d8043c75f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Node::Node </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor, should only be called by parent, not directly. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Generates a name. </dd></dl>

</div>
</div>
<a class="anchor" id="abc80390991fd1d39a91fc242ef48acff"></a><!-- doxytag: member="oengine::Node::Node" ref="abc80390991fd1d39a91fc242ef48acff" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Node::Node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceomega.html#a39676bdac3c610b014bda97c88a94083">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor, should only be called by parent, not directly. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Assigned a name. </dd></dl>

</div>
</div>
<a class="anchor" id="aa0840c3cb5c7159be6d992adecd2097c"></a><!-- doxytag: member="oengine::Node::~Node" ref="aa0840c3cb5c7159be6d992adecd2097c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Node::~Node </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a7f307f4db1ed12de20502e3c80f38296"></a><!-- doxytag: member="oengine::Node::_setDerivedOrientation" ref="a7f307f4db1ed12de20502e3c80f38296" args="(const Quaternion &amp;q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::_setDerivedOrientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classomega_1_1math_1_1quaternion.html">Quaternion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the final world orientation of the node directly. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>It's advisable to use the local setOrientation if possible, this simply does the conversion for you. </dd></dl>

</div>
</div>
<a class="anchor" id="ac51ec82eb287dd044c49b7f0e3468399"></a><!-- doxytag: member="oengine::Node::_setDerivedPosition" ref="ac51ec82eb287dd044c49b7f0e3468399" args="(const Vector3f &amp;pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::_setDerivedPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the final world position of the node directly. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>It's advisable to use the local setPosition if possible </dd></dl>

</div>
</div>
<a class="anchor" id="a132699398b350e83b548a5645e69beb0"></a><!-- doxytag: member="oengine::Node::addChild" ref="a132699398b350e83b548a5645e69beb0" args="(Node *child)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoengine_1_1_node.html">Node</a> *&nbsp;</td>
          <td class="paramname"> <em>child</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a (precreated) child scene node to this node. </p>
<p>If it is attached to another node, it must be detached first. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>child</em>&nbsp;</td><td>The <a class="el" href="classoengine_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> which is to become a child node of this one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad6aea1f4b27416f969b890c093e975e3"></a><!-- doxytag: member="oengine::Node::cancelUpdate" ref="ad6aea1f4b27416f969b890c093e975e3" args="(Node *child)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::cancelUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoengine_1_1_node.html">Node</a> *&nbsp;</td>
          <td class="paramname"> <em>child</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called by children to notify their parent that they no longer need an update. </p>

</div>
</div>
<a class="anchor" id="ac6eb73a591d1c7b7b4e0c7f030c7aa5d"></a><!-- doxytag: member="oengine::Node::convertLocalToWorldOrientation" ref="ac6eb73a591d1c7b7b4e0c7f030c7aa5d" args="(const Quaternion &amp;localOrientation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomega_1_1math_1_1quaternion.html">Quaternion</a> Node::convertLocalToWorldOrientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classomega_1_1math_1_1quaternion.html">Quaternion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>localOrientation</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the world orientation of an orientation in the node local space useful for simple transforms that don't require a child node. </p>

</div>
</div>
<a class="anchor" id="a896cf7cdd883bb9f358b31c4887218a5"></a><!-- doxytag: member="oengine::Node::convertLocalToWorldPosition" ref="a896cf7cdd883bb9f358b31c4887218a5" args="(const Vector3f &amp;localPos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> Node::convertLocalToWorldPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>localPos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the world position of a point in the node local space useful for simple transforms that don't require a child node. </p>

</div>
</div>
<a class="anchor" id="aec2034e74729a7651383db2c4b292cfc"></a><!-- doxytag: member="oengine::Node::convertWorldToLocalOrientation" ref="aec2034e74729a7651383db2c4b292cfc" args="(const Quaternion &amp;worldOrientation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomega_1_1math_1_1quaternion.html">Quaternion</a> Node::convertWorldToLocalOrientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classomega_1_1math_1_1quaternion.html">Quaternion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>worldOrientation</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the local orientation, relative to this node, of the given world-space orientation. </p>

</div>
</div>
<a class="anchor" id="a2fc2f74f73811c39d3db4650063e7697"></a><!-- doxytag: member="oengine::Node::convertWorldToLocalPosition" ref="a2fc2f74f73811c39d3db4650063e7697" args="(const Vector3f &amp;worldPos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> Node::convertWorldToLocalPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>worldPos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the local position, relative to this node, of the given world-space position. </p>

</div>
</div>
<a class="anchor" id="a564866c72a3ca1b824804711e1ba5a8e"></a><!-- doxytag: member="oengine::Node::getChild" ref="a564866c72a3ca1b824804711e1ba5a8e" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoengine_1_1_node.html">Node</a> * Node::getChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceomega.html#a39676bdac3c610b014bda97c88a94083">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a pointer to a named child node. </p>

</div>
</div>
<a class="anchor" id="af01f5814115581c55ef5b8c08a8020dc"></a><!-- doxytag: member="oengine::Node::getChild" ref="af01f5814115581c55ef5b8c08a8020dc" args="(unsigned short index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoengine_1_1_node.html">Node</a> * Node::getChild </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a pointer to a child node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>There is an alternate getChild method which returns a named child. </dd></dl>

</div>
</div>
<a class="anchor" id="ac5c725178891f63f4268d462f2b9ca22"></a><!-- doxytag: member="oengine::Node::getChildren" ref="ac5c725178891f63f4268d462f2b9ca22" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoengine_1_1_node.html#abda68a9b598fd3c702d9cc5c646b7782">Node::ConstChildNodeRange</a> Node::getChildren </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves an iterator for efficiently looping through all children of this node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Using this is faster than repeatedly calling getChild if you want to go through all (or most of) the children of this node. Note that the returned iterator is only valid whilst no children are added or removed from this node. Thus you should not store this returned iterator for later use, nor should you add / remove children whilst iterating through it; store up changes for later. Note that calling methods on returned items in the iterator IS allowed and does not invalidate the iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a766074721094059081a7d94f88e3f0"></a><!-- doxytag: member="oengine::Node::getChildren" ref="a2a766074721094059081a7d94f88e3f0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoengine_1_1_node.html#a8a96abed8ee68282024729925216aa57">Node::ChildNodeRange</a> Node::getChildren </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves an iterator for efficiently looping through all children of this node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Using this is faster than repeatedly calling getChild if you want to go through all (or most of) the children of this node. Note that the returned iterator is only valid whilst no children are added or removed from this node. Thus you should not store this returned iterator for later use, nor should you add / remove children whilst iterating through it; store up changes for later. Note that calling methods on returned items in the iterator IS allowed and does not invalidate the iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="abb87f0ae54132573e7b786c8415cf738"></a><!-- doxytag: member="oengine::Node::getDerivedOrientation" ref="abb87f0ae54132573e7b786c8415cf738" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classomega_1_1math_1_1quaternion.html">Quaternion</a> &amp; Node::getDerivedOrientation </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the orientation of the node as derived from all parents. </p>

</div>
</div>
<a class="anchor" id="a23a511816193475645b32d819705a3a9"></a><!-- doxytag: member="oengine::Node::getDerivedPosition" ref="a23a511816193475645b32d819705a3a9" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> &amp; Node::getDerivedPosition </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the position of the node as derived from all parents. </p>

</div>
</div>
<a class="anchor" id="ad519b253d070fb5c8ab8ff33585fa251"></a><!-- doxytag: member="oengine::Node::getDerivedScale" ref="ad519b253d070fb5c8ab8ff33585fa251" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> &amp; Node::getDerivedScale </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the scaling factor of the node as derived from all parents. </p>

</div>
</div>
<a class="anchor" id="a46620526683ba6fd76a3669bdf46ab9f"></a><!-- doxytag: member="oengine::Node::getFullTransform" ref="a46620526683ba6fd76a3669bdf46ab9f" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classomega_1_1math_1_1transform.html">AffineTransform3</a> &amp; Node::getFullTransform </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the full transformation matrix for this node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This method returns the full transformation matrix for this node, including the effect of any parent node transformations, provided they have been updated using the Node::_update method. This should only be called by a <a class="el" href="classoengine_1_1_scene_manager.html">SceneManager</a> which knows the derived transforms have been updated before calling this method. Applications using Ogre should just use the relative transforms. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d08daa0534eb9163fe737762a03f779"></a><!-- doxytag: member="oengine::Node::getInheritOrientation" ref="a4d08daa0534eb9163fe737762a03f779" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::getInheritOrientation </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this node is affected by orientation applied to the parent node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Orientations, unlike other transforms, are not always inherited by child nodes. Whether or not orientations affect the orientation of the child nodes depends on the setInheritOrientation option of the child. In some cases you want a orientating of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative orientation based on the parent's orientation), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own orientation). The default is to inherit as with other transforms. </dd>
<dd>
See setInheritOrientation for more info. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c80249647c02b895455e60124f197aa"></a><!-- doxytag: member="oengine::Node::getInheritScale" ref="a6c80249647c02b895455e60124f197aa" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::getInheritScale </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this node is affected by scaling factors applied to the parent node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>See setInheritScale for more info. </dd></dl>

</div>
</div>
<a class="anchor" id="aac21f9d5bedf6bd5f26909c5ed5d079c"></a><!-- doxytag: member="oengine::Node::getLocalAxes" ref="aac21f9d5bedf6bd5f26909c5ed5d079c" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomega_1_1math_1_1matrix.html">Matrix3f</a> Node::getLocalAxes </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a matrix whose columns are the local axes based on the nodes orientation relative to it's parent. </p>

</div>
</div>
<a class="anchor" id="ae4c4b3e59bd1bb71938bc2d9dd03d854"></a><!-- doxytag: member="oengine::Node::getName" ref="ae4c4b3e59bd1bb71938bc2d9dd03d854" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceomega.html#a39676bdac3c610b014bda97c88a94083">String</a> &amp; Node::getName </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the name of the node. </p>

</div>
</div>
<a class="anchor" id="a283ad23df5d5f242124ddde24978b750"></a><!-- doxytag: member="oengine::Node::getOrientation" ref="a283ad23df5d5f242124ddde24978b750" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classomega_1_1math_1_1quaternion.html">Quaternion</a> &amp; Node::getOrientation </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a quaternion representing the nodes orientation. </p>

</div>
</div>
<a class="anchor" id="a6bbbaa13612a795cf99c6f4cdd749ab2"></a><!-- doxytag: member="oengine::Node::getParent" ref="a6bbbaa13612a795cf99c6f4cdd749ab2" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoengine_1_1_node.html">Node</a> * Node::getParent </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets this node's parent (NULL if this is the root). </p>

</div>
</div>
<a class="anchor" id="aa622e5d30fda76de12196213a991dbc5"></a><!-- doxytag: member="oengine::Node::getPosition" ref="aa622e5d30fda76de12196213a991dbc5" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> &amp; Node::getPosition </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the position of the node relative to it's parent. </p>

</div>
</div>
<a class="anchor" id="a3b96c4807eb588ca98501ba9e55bb102"></a><!-- doxytag: member="oengine::Node::getScale" ref="a3b96c4807eb588ca98501ba9e55bb102" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> &amp; Node::getScale </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the scaling factor of this node. </p>

</div>
</div>
<a class="anchor" id="aca8d4cdafb6b8c092db04636e3e02f46"></a><!-- doxytag: member="oengine::Node::getUserData" ref="aca8d4cdafb6b8c092db04636e3e02f46" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* oengine::Node::getUserData </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abdf9e4efde4e839e611080aa6522e49d"></a><!-- doxytag: member="oengine::Node::needUpdate" ref="abdf9e4efde4e839e611080aa6522e49d" args="(bool forceParentUpdate=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::needUpdate </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>forceParentUpdate</em> = <code>true</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>To be called in the event of transform changes to this node that require it's recalculation. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This not only tags the node state as being 'dirty', it also requests it's parent to know about it's dirtiness so it will get an update next time. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>forceParentUpdate</em>&nbsp;</td><td>Even if the node thinks it has already told it's parent, tell it anyway </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8e9c1b334429fdb83b891cbcc51349e"></a><!-- doxytag: member="oengine::Node::numChildren" ref="ae8e9c1b334429fdb83b891cbcc51349e" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short Node::numChildren </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reports the number of child nodes under this one. </p>

</div>
</div>
<a class="anchor" id="adf779c06f0bbe3616c4515ddc6856db2"></a><!-- doxytag: member="oengine::Node::pitch" ref="adf779c06f0bbe3616c4515ddc6856db2" args="(const float &amp;angle, TransformSpace relativeTo=TransformLocal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::pitch </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&nbsp;</td>
          <td class="paramname"> <em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoengine_1_1_node.html#a54449e99f7265401c2e8fa53ae66be15">TransformSpace</a>&nbsp;</td>
          <td class="paramname"> <em>relativeTo</em> = <code>TransformLocal</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate the node around the X-axis. </p>

</div>
</div>
<a class="anchor" id="acafef630e549df6bcc439975c4fbefa5"></a><!-- doxytag: member="oengine::Node::removeAllChildren" ref="acafef630e549df6bcc439975c4fbefa5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::removeAllChildren </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all child Nodes attached to this node. </p>
<p>Does not delete the nodes, just detaches them from this parent, potentially to be reattached elsewhere. </p>

</div>
</div>
<a class="anchor" id="aabae61b372af0f21c2d779126561e997"></a><!-- doxytag: member="oengine::Node::removeChild" ref="aabae61b372af0f21c2d779126561e997" args="(unsigned short index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoengine_1_1_node.html">Node</a> * Node::removeChild </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Drops the specified child from this node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Does not delete the node, just detaches it from this parent, potentially to be reattached elsewhere. There is also an alternate version which drops a named child from this node. </dd></dl>

</div>
</div>
<a class="anchor" id="a59de321fe407af320e4ff145f0a304fb"></a><!-- doxytag: member="oengine::Node::removeChild" ref="a59de321fe407af320e4ff145f0a304fb" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoengine_1_1_node.html">Node</a> * Node::removeChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceomega.html#a39676bdac3c610b014bda97c88a94083">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Drops the named child from this node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Does not delete the node, just detaches it from this parent, potentially to be reattached elsewhere. </dd></dl>

</div>
</div>
<a class="anchor" id="ab53dd6926b0e922b8ed671d9cda1be7b"></a><!-- doxytag: member="oengine::Node::removeChild" ref="ab53dd6926b0e922b8ed671d9cda1be7b" args="(Node *child)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoengine_1_1_node.html">Node</a> * Node::removeChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoengine_1_1_node.html">Node</a> *&nbsp;</td>
          <td class="paramname"> <em>child</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Drops the specified child from this node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Does not delete the node, just detaches it from this parent, potentially to be reattached elsewhere. There is also an alternate version which drops a named child from this node. </dd></dl>

</div>
</div>
<a class="anchor" id="aeabf6c5a2d88d38586a01897da70bf7a"></a><!-- doxytag: member="oengine::Node::requestUpdate" ref="aeabf6c5a2d88d38586a01897da70bf7a" args="(Node *child, bool forceParentUpdate=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::requestUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoengine_1_1_node.html">Node</a> *&nbsp;</td>
          <td class="paramname"> <em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>forceParentUpdate</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called by children to notify their parent that they need an update. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>forceParentUpdate</em>&nbsp;</td><td>Even if the node thinks it has already told it's parent, tell it anyway </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa51b83655c10fc6286043e389c2d8164"></a><!-- doxytag: member="oengine::Node::resetOrientation" ref="aa51b83655c10fc6286043e389c2d8164" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::resetOrientation </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets the nodes orientation (local axes as world axes, no rotation). </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Orientations, unlike other transforms, are not always inherited by child nodes. Whether or not orientations affect the orientation of the child nodes depends on the setInheritOrientation option of the child. In some cases you want a orientating of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative orientation based on the parent's orientation), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own orientation). The default is to inherit as with other transforms. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that rotations are oriented around the node's origin. </dd></dl>

</div>
</div>
<a class="anchor" id="a6e3b4139e301abd98e0f34d026797db5"></a><!-- doxytag: member="oengine::Node::roll" ref="a6e3b4139e301abd98e0f34d026797db5" args="(const float &amp;angle, TransformSpace relativeTo=TransformLocal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::roll </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&nbsp;</td>
          <td class="paramname"> <em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoengine_1_1_node.html#a54449e99f7265401c2e8fa53ae66be15">TransformSpace</a>&nbsp;</td>
          <td class="paramname"> <em>relativeTo</em> = <code>TransformLocal</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate the node around the Z-axis. </p>

</div>
</div>
<a class="anchor" id="a3f60558c0dab25655e8c6a0f3d2c26ab"></a><!-- doxytag: member="oengine::Node::rotate" ref="a3f60558c0dab25655e8c6a0f3d2c26ab" args="(const Vector3f &amp;axis, const float &amp;angle, TransformSpace relativeTo=TransformLocal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float &amp;&nbsp;</td>
          <td class="paramname"> <em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoengine_1_1_node.html#a54449e99f7265401c2e8fa53ae66be15">TransformSpace</a>&nbsp;</td>
          <td class="paramname"> <em>relativeTo</em> = <code>TransformLocal</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate the node around an arbitrary axis. </p>

</div>
</div>
<a class="anchor" id="af5c1c904284aa895e1631ac3f9a226c7"></a><!-- doxytag: member="oengine::Node::rotate" ref="af5c1c904284aa895e1631ac3f9a226c7" args="(const Quaternion &amp;q, TransformSpace relativeTo=TransformLocal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classomega_1_1math_1_1quaternion.html">Quaternion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoengine_1_1_node.html#a54449e99f7265401c2e8fa53ae66be15">TransformSpace</a>&nbsp;</td>
          <td class="paramname"> <em>relativeTo</em> = <code>TransformLocal</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate the node around an aritrary axis using a Quarternion. </p>

</div>
</div>
<a class="anchor" id="a76397bf505156bfa7f0f6daf072446b4"></a><!-- doxytag: member="oengine::Node::scale" ref="a76397bf505156bfa7f0f6daf072446b4" args="(const Vector3f &amp;scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>scale</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales the node, combining it's current scale with the passed in scaling factor. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This method applies an extra scaling factor to the node's existing scale, (unlike setScale which overwrites it) combining it's current scale with the new one. E.g. calling this method twice with Vector3f(2,2,2) would have the same effect as setScale(Vector3f(4,4,4)) if the existing scale was 1. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that like rotations, scalings are oriented around the node's origin. </dd></dl>

</div>
</div>
<a class="anchor" id="a516253fce2a299665b26d664a3dd7735"></a><!-- doxytag: member="oengine::Node::scale" ref="a516253fce2a299665b26d664a3dd7735" args="(float x, float y, float z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::scale </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales the node, combining it's current scale with the passed in scaling factor. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This method applies an extra scaling factor to the node's existing scale, (unlike setScale which overwrites it) combining it's current scale with the new one. E.g. calling this method twice with Vector3f(2,2,2) would have the same effect as setScale(Vector3f(4,4,4)) if the existing scale was 1. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that like rotations, scalings are oriented around the node's origin. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a9ea1aa33df4b47b0e88e37ab95c3f9"></a><!-- doxytag: member="oengine::Node::setInheritOrientation" ref="a4a9ea1aa33df4b47b0e88e37ab95c3f9" args="(bool inherit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setInheritOrientation </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>inherit</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells the node whether it should inherit orientation from it's parent node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Orientations, unlike other transforms, are not always inherited by child nodes. Whether or not orientations affect the orientation of the child nodes depends on the setInheritOrientation option of the child. In some cases you want a orientating of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative orientation based on the parent's orientation), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own orientation). The default is to inherit as with other transforms. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inherit</em>&nbsp;</td><td>If true, this node's orientation will be affected by its parent's orientation. If false, it will not be affected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a08ab23ea9bb1b71ba28f18e0fef1569a"></a><!-- doxytag: member="oengine::Node::setInheritScale" ref="a08ab23ea9bb1b71ba28f18e0fef1569a" args="(bool inherit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setInheritScale </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>inherit</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells the node whether it should inherit scaling factors from it's parent node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Scaling factors, unlike other transforms, are not always inherited by child nodes. Whether or not scalings affect the size of the child nodes depends on the setInheritScale option of the child. In some cases you want a scaling factor of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative size based on the parent's size), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own size). The default is to inherit as with other transforms. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inherit</em>&nbsp;</td><td>If true, this node's scale will be affected by its parent's scale. If false, it will not be affected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a13ab180dc837777519e338bc4d03f9b0"></a><!-- doxytag: member="oengine::Node::setOrientation" ref="a13ab180dc837777519e338bc4d03f9b0" args="(const Quaternion &amp;q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setOrientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classomega_1_1math_1_1quaternion.html">Quaternion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the orientation of this node via a quaternion. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Orientations, unlike other transforms, are not always inherited by child nodes. Whether or not orientations affect the orientation of the child nodes depends on the setInheritOrientation option of the child. In some cases you want a orientating of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative orientation based on the parent's orientation), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own orientation). The default is to inherit as with other transforms. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that rotations are oriented around the node's origin. </dd></dl>

</div>
</div>
<a class="anchor" id="a7cc8794fe7a3c0f9dc45415aaeed8b12"></a><!-- doxytag: member="oengine::Node::setOrientation" ref="a7cc8794fe7a3c0f9dc45415aaeed8b12" args="(float w, float x, float y, float z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setOrientation </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the orientation of this node via quaternion parameters. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Orientations, unlike other transforms, are not always inherited by child nodes. Whether or not orientations affect the orientation of the child nodes depends on the setInheritOrientation option of the child. In some cases you want a orientating of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative orientation based on the parent's orientation), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own orientation). The default is to inherit as with other transforms. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that rotations are oriented around the node's origin. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5f0786bcb59591c528efb0b776797fc"></a><!-- doxytag: member="oengine::Node::setParent" ref="ab5f0786bcb59591c528efb0b776797fc" args="(Node *parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoengine_1_1_node.html">Node</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Only available internally - notification of parent. </p>

</div>
</div>
<a class="anchor" id="ad9899110e543c6b16997512e47c142c9"></a><!-- doxytag: member="oengine::Node::setPosition" ref="ad9899110e543c6b16997512e47c142c9" args="(float x, float y, float z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setPosition </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the position of the node relative to it's parent. </p>

</div>
</div>
<a class="anchor" id="ac1003c7557c52ec7577a83f582bd493d"></a><!-- doxytag: member="oengine::Node::setPosition" ref="ac1003c7557c52ec7577a83f582bd493d" args="(const Vector3f &amp;pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the position of the node relative to it's parent. </p>

</div>
</div>
<a class="anchor" id="a6769cc1b09a34b9b8ab7b49b2232b1cb"></a><!-- doxytag: member="oengine::Node::setScale" ref="a6769cc1b09a34b9b8ab7b49b2232b1cb" args="(const Vector3f &amp;scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setScale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>scale</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the scaling factor applied to this node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Scaling factors, unlike other transforms, are not always inherited by child nodes. Whether or not scalings affect the size of the child nodes depends on the setInheritScale option of the child. In some cases you want a scaling factor of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative size based on the parent's size), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own size). The default is to inherit as with other transforms. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that like rotations, scalings are oriented around the node's origin. </dd></dl>

</div>
</div>
<a class="anchor" id="a125dcc8deb6d08a2f7b6794453c47e9a"></a><!-- doxytag: member="oengine::Node::setScale" ref="a125dcc8deb6d08a2f7b6794453c47e9a" args="(float x, float y, float z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setScale </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the scaling factor applied to this node. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Scaling factors, unlike other transforms, are not always inherited by child nodes. Whether or not scalings affect the size of the child nodes depends on the setInheritScale option of the child. In some cases you want a scaling factor of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative size based on the parent's size), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own size). The default is to inherit as with other transforms. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that like rotations, scalings are oriented around the node's origin. </dd></dl>

</div>
</div>
<a class="anchor" id="a59fa62cd44bf4579401e29d73b3ece26"></a><!-- doxytag: member="oengine::Node::setUserData" ref="a59fa62cd44bf4579401e29d73b3ece26" args="(void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oengine::Node::setUserData </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a44f4daf23a85bded31903a6245bfb4a4"></a><!-- doxytag: member="oengine::Node::translate" ref="a44f4daf23a85bded31903a6245bfb4a4" args="(float x, float y, float z, TransformSpace relativeTo=TransformParent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::translate </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoengine_1_1_node.html#a54449e99f7265401c2e8fa53ae66be15">TransformSpace</a>&nbsp;</td>
          <td class="paramname"> <em>relativeTo</em> = <code>TransformParent</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the node along the Cartesian axes. </p>
<dl class="user"><dt><b></b></dt><dd>This method moves the node by the supplied vector along the world Cartesian axes, i.e. along world x,y,z </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>z</em>&nbsp;</td><td>float x, y and z values representing the translation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relativeTo</em>&nbsp;</td><td>The space which this transform is relative to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac342819f2821de82cb841ff95e22f880"></a><!-- doxytag: member="oengine::Node::translate" ref="ac342819f2821de82cb841ff95e22f880" args="(const Vector3f &amp;d, TransformSpace relativeTo=TransformParent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoengine_1_1_node.html#a54449e99f7265401c2e8fa53ae66be15">TransformSpace</a>&nbsp;</td>
          <td class="paramname"> <em>relativeTo</em> = <code>TransformParent</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the node along the Cartesian axes. </p>
<dl class="user"><dt><b></b></dt><dd>This method moves the node by the supplied vector along the world Cartesian axes, i.e. along world x,y,z </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>d</em>&nbsp;</td><td>Vector with x,y,z values representing the translation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relativeTo</em>&nbsp;</td><td>The space which this transform is relative to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa10278966cbe55dbaa393e1f5184da64"></a><!-- doxytag: member="oengine::Node::translate" ref="aa10278966cbe55dbaa393e1f5184da64" args="(const Matrix3f &amp;axes, const Vector3f &amp;move, TransformSpace relativeTo=TransformParent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classomega_1_1math_1_1matrix.html">Matrix3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>move</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoengine_1_1_node.html#a54449e99f7265401c2e8fa53ae66be15">TransformSpace</a>&nbsp;</td>
          <td class="paramname"> <em>relativeTo</em> = <code>TransformParent</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the node along arbitrary axes. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This method translates the node by a vector which is relative to a custom set of axes. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>A 3x3 Matrix containg 3 column vectors each representing the axes X, Y and Z respectively. In this format the standard cartesian axes would be expressed as: </p>
<pre>
                1 0 0
                0 1 0
                0 0 1
                </pre><p> i.e. the identity matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>move</em>&nbsp;</td><td>Vector relative to the axes above. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relativeTo</em>&nbsp;</td><td>The space which this transform is relative to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a55dab67b1ccce531bf19d0c51181f4e6"></a><!-- doxytag: member="oengine::Node::translate" ref="a55dab67b1ccce531bf19d0c51181f4e6" args="(const Matrix3f &amp;axes, float x, float y, float z, TransformSpace relativeTo=TransformParent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classomega_1_1math_1_1matrix.html">Matrix3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoengine_1_1_node.html#a54449e99f7265401c2e8fa53ae66be15">TransformSpace</a>&nbsp;</td>
          <td class="paramname"> <em>relativeTo</em> = <code>TransformParent</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the node along arbitrary axes. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This method translates the node by a vector which is relative to a custom set of axes. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>A 3x3 Matrix containg 3 column vectors each representing the axes X, Y and Z respectively. In this format the standard cartesian axes would be expressed as </p>
<pre>
                1 0 0
                0 1 0
                0 0 1
                </pre><p> i.e. the identity matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x,y,z</em>&nbsp;</td><td>Translation components relative to the axes above. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relativeTo</em>&nbsp;</td><td>The space which this transform is relative to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae3541d1bf654e3d7788aae3021adba64"></a><!-- doxytag: member="oengine::Node::update" ref="ae3541d1bf654e3d7788aae3021adba64" args="(bool updateChildren, bool parentHasChanged)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::update </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>updateChildren</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>parentHasChanged</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal method to update the <a class="el" href="classoengine_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Updates this node and any relevant children to incorporate transforms etc. Don't call this yourself unless you are writing a <a class="el" href="classoengine_1_1_scene_manager.html">SceneManager</a> implementation. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>updateChildren</em>&nbsp;</td><td>If true, the update cascades down to all children. Specify false if you wish to update children separately, e.g. because of a more selective <a class="el" href="classoengine_1_1_scene_manager.html">SceneManager</a> implementation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parentHasChanged</em>&nbsp;</td><td>This flag indicates that the parent xform has changed, so the child should retrieve the parent's xform and combine it with its own even if it hasn't changed itself. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classoengine_1_1_scene_node.html#aa01f6997768b5007a99630353f114aa6">oengine::SceneNode</a>.</p>

</div>
</div>
<a class="anchor" id="a96d6e9970e1330f0c7b3e990ea5b3556"></a><!-- doxytag: member="oengine::Node::updateFromParent" ref="a96d6e9970e1330f0c7b3e990ea5b3556" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::updateFromParent </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Class-specific implementation of updateFromParent. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Splitting the implementation of the update away from the update call itself allows the detail to be overridden without disrupting the general sequence of updateFromParent (e.g. raising events) </dd></dl>

</div>
</div>
<a class="anchor" id="a5849b42a4239ff95574e5910b25aa6a5"></a><!-- doxytag: member="oengine::Node::yaw" ref="a5849b42a4239ff95574e5910b25aa6a5" args="(const float &amp;angle, TransformSpace relativeTo=TransformLocal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::yaw </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&nbsp;</td>
          <td class="paramname"> <em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoengine_1_1_node.html#a54449e99f7265401c2e8fa53ae66be15">TransformSpace</a>&nbsp;</td>
          <td class="paramname"> <em>relativeTo</em> = <code>TransformLocal</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate the node around the Y-axis. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ae1584f0e1d57ab1030aac671f7aaa79f"></a><!-- doxytag: member="oengine::Node::mCachedTransform" ref="ae1584f0e1d57ab1030aac671f7aaa79f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomega_1_1math_1_1transform.html">AffineTransform3</a> <a class="el" href="classoengine_1_1_node.html#ae1584f0e1d57ab1030aac671f7aaa79f">oengine::Node::mCachedTransform</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cached derived transform as a 4x4 matrix. </p>

</div>
</div>
<a class="anchor" id="aaad079ece87a65947783b57aa0a661df"></a><!-- doxytag: member="oengine::Node::mCachedTransformOutOfDate" ref="aaad079ece87a65947783b57aa0a661df" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoengine_1_1_node.html#aaad079ece87a65947783b57aa0a661df">oengine::Node::mCachedTransformOutOfDate</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa315555b79e175c3b22c7b312d12053d"></a><!-- doxytag: member="oengine::Node::mChildren" ref="aa315555b79e175c3b22c7b312d12053d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomega_1_1_dictionary.html">ChildNodeMap</a> <a class="el" href="classoengine_1_1_node.html#aa315555b79e175c3b22c7b312d12053d">oengine::Node::mChildren</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Collection of pointers to direct children; hashmap for efficiency. </p>

</div>
</div>
<a class="anchor" id="a13e261a92137e13298729346a82a019c"></a><!-- doxytag: member="oengine::Node::mChildrenToUpdate" ref="a13e261a92137e13298729346a82a019c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoengine_1_1_node.html#af48f70359ff07e35a7600418d52abfe0">ChildUpdateSet</a> <a class="el" href="classoengine_1_1_node.html#a13e261a92137e13298729346a82a019c">oengine::Node::mChildrenToUpdate</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>List of children which need updating, used if self is not out of date but children are. </p>

</div>
</div>
<a class="anchor" id="ab3edb6ec78b739e6c6bec89dd102325d"></a><!-- doxytag: member="oengine::Node::mDerivedOrientation" ref="ab3edb6ec78b739e6c6bec89dd102325d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomega_1_1math_1_1quaternion.html">Quaternion</a> <a class="el" href="classoengine_1_1_node.html#ab3edb6ec78b739e6c6bec89dd102325d">oengine::Node::mDerivedOrientation</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cached combined orientation. </p>
<dl class="user"><dt><b></b></dt><dd>This member is the orientation derived by combining the local transformations and those of it's parents. This is updated when updateFromParent is called by the <a class="el" href="classoengine_1_1_scene_manager.html">SceneManager</a> or the nodes parent. </dd></dl>

</div>
</div>
<a class="anchor" id="ad544fd680104b680e0acc5451126980c"></a><!-- doxytag: member="oengine::Node::mDerivedPosition" ref="ad544fd680104b680e0acc5451126980c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> <a class="el" href="classoengine_1_1_node.html#ad544fd680104b680e0acc5451126980c">oengine::Node::mDerivedPosition</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cached combined position. </p>
<dl class="user"><dt><b></b></dt><dd>This member is the position derived by combining the local transformations and those of it's parents. This is updated when updateFromParent is called by the <a class="el" href="classoengine_1_1_scene_manager.html">SceneManager</a> or the nodes parent. </dd></dl>

</div>
</div>
<a class="anchor" id="ae53b20e9a311e2ef6b9fdb81265253a6"></a><!-- doxytag: member="oengine::Node::mDerivedScale" ref="ae53b20e9a311e2ef6b9fdb81265253a6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> <a class="el" href="classoengine_1_1_node.html#ae53b20e9a311e2ef6b9fdb81265253a6">oengine::Node::mDerivedScale</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cached combined scale. </p>
<dl class="user"><dt><b></b></dt><dd>This member is the position derived by combining the local transformations and those of it's parents. This is updated when updateFromParent is called by the <a class="el" href="classoengine_1_1_scene_manager.html">SceneManager</a> or the nodes parent. </dd></dl>

</div>
</div>
<a class="anchor" id="ae02f1d7101c18caf1133b01af8f29300"></a><!-- doxytag: member="oengine::Node::mInheritOrientation" ref="ae02f1d7101c18caf1133b01af8f29300" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoengine_1_1_node.html#ae02f1d7101c18caf1133b01af8f29300">oengine::Node::mInheritOrientation</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stores whether this node inherits orientation from it's parent. </p>

</div>
</div>
<a class="anchor" id="a31a2e3c14ce154f265ef089568ed58be"></a><!-- doxytag: member="oengine::Node::mInheritScale" ref="a31a2e3c14ce154f265ef089568ed58be" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoengine_1_1_node.html#a31a2e3c14ce154f265ef089568ed58be">oengine::Node::mInheritScale</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stores whether this node inherits scale from it's parent. </p>

</div>
</div>
<a class="anchor" id="a9748e38c6e97c5eec5614e8ce169a22f"></a><!-- doxytag: member="oengine::Node::mName" ref="a9748e38c6e97c5eec5614e8ce169a22f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceomega.html#a39676bdac3c610b014bda97c88a94083">String</a> <a class="el" href="classoengine_1_1_node.html#a9748e38c6e97c5eec5614e8ce169a22f">oengine::Node::mName</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Friendly name of this node, can be automatically generated if you don't care. </p>

</div>
</div>
<a class="anchor" id="a099588575a4f0aca8985fda435c7e560"></a><!-- doxytag: member="oengine::Node::mNeedChildUpdate" ref="a099588575a4f0aca8985fda435c7e560" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoengine_1_1_node.html#a099588575a4f0aca8985fda435c7e560">oengine::Node::mNeedChildUpdate</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag indicating that all children need to be updated. </p>

</div>
</div>
<a class="anchor" id="a08095d9783d4b1d141f5bc02028e9f56"></a><!-- doxytag: member="oengine::Node::mNeedParentUpdate" ref="a08095d9783d4b1d141f5bc02028e9f56" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoengine_1_1_node.html#a08095d9783d4b1d141f5bc02028e9f56">oengine::Node::mNeedParentUpdate</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag to indicate own transform from parent is out of date. </p>

</div>
</div>
<a class="anchor" id="a1800d35b28a18939dddba18a0fc6cb93"></a><!-- doxytag: member="oengine::Node::mOrientation" ref="a1800d35b28a18939dddba18a0fc6cb93" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomega_1_1math_1_1quaternion.html">Quaternion</a> <a class="el" href="classoengine_1_1_node.html#a1800d35b28a18939dddba18a0fc6cb93">oengine::Node::mOrientation</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stores the orientation of the node relative to it's parent. </p>

</div>
</div>
<a class="anchor" id="abe598ebd5ecaa51fa224e176a8f5d92a"></a><!-- doxytag: member="oengine::Node::mParent" ref="abe598ebd5ecaa51fa224e176a8f5d92a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoengine_1_1_node.html">Node</a>* <a class="el" href="classoengine_1_1_node.html#abe598ebd5ecaa51fa224e176a8f5d92a">oengine::Node::mParent</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classoengine_1_1_pointer.html">Pointer</a> to parent node. </p>

</div>
</div>
<a class="anchor" id="a0bd03111048bc671491fa232ad514312"></a><!-- doxytag: member="oengine::Node::mParentNotified" ref="a0bd03111048bc671491fa232ad514312" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoengine_1_1_node.html#a0bd03111048bc671491fa232ad514312">oengine::Node::mParentNotified</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag indicating that parent has been notified about update request. </p>

</div>
</div>
<a class="anchor" id="a96c2cbc83bbcd789e128233a43db1c50"></a><!-- doxytag: member="oengine::Node::mPosition" ref="a96c2cbc83bbcd789e128233a43db1c50" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> <a class="el" href="classoengine_1_1_node.html#a96c2cbc83bbcd789e128233a43db1c50">oengine::Node::mPosition</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stores the position/translation of the node relative to its parent. </p>

</div>
</div>
<a class="anchor" id="a1db450f68bcb28701c83b4282a20110d"></a><!-- doxytag: member="oengine::Node::mQueuedForUpdate" ref="a1db450f68bcb28701c83b4282a20110d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoengine_1_1_node.html#a1db450f68bcb28701c83b4282a20110d">oengine::Node::mQueuedForUpdate</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag indicating that the node has been queued for update. </p>

</div>
</div>
<a class="anchor" id="a7e37a9366ee71f2d85d75349f50b144f"></a><!-- doxytag: member="oengine::Node::mScale" ref="a7e37a9366ee71f2d85d75349f50b144f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomega_1_1math_1_1vector.html">Vector3f</a> <a class="el" href="classoengine_1_1_node.html#a7e37a9366ee71f2d85d75349f50b144f">oengine::Node::mScale</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stores the scaling factor applied to this node. </p>

</div>
</div>
<a class="anchor" id="a36abee23a90b97fa3b833ed1fd39bf44"></a><!-- doxytag: member="oengine::Node::msNameGenerator" ref="a36abee23a90b97fa3b833ed1fd39bf44" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classomega_1_1_name_generator.html">NameGenerator</a> <a class="el" href="classoengine_1_1_node.html#a36abee23a90b97fa3b833ed1fd39bf44">Node::msNameGenerator</a><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Incremented count for next name extension. </p>

</div>
</div>
<a class="anchor" id="a6a026cb0dfbb5e855ff6d1103a0693f2"></a><!-- doxytag: member="oengine::Node::myUserData" ref="a6a026cb0dfbb5e855ff6d1103a0693f2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classoengine_1_1_node.html#a6a026cb0dfbb5e855ff6d1103a0693f2">oengine::Node::myUserData</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
